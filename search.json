[{"title":"计组P0——Logisim 和 状态机","url":"/2025/09/30/COP0/","content":"课下grf\n子模块不能复用\n先做完子单元在复制\n记得改标签\n\nfsm最主要的问题是同步复位，为了控制是在上升沿接收，我选择用一个寄存器来存复位信息，但是这个复位该不该包含本身呢？\n如果包含了，就只会形成一个小刺虽说好像也可以吧，但是安全性要打个问号\n如果不包含呢，下一个上升沿就会涉及到输入到了但是复位还没归零的问题，总之就是不很美观\n所以最后采用了往年博客中的搭建方法，用多路选择器，如果复位信息被激活那就选择0，否则选择本身\nftoi不要排线太挤\n貌似评测的时候会对提交的 circuit 进行缩放之类的？然后就会让本来不该连在一起的线连起来了\n这个错误还是挺难分析出来的，如果上机遇到就寄了\n课上异步复位逻辑最方便的是利用寄存器自带的 0 搞事，我用的是做差方法，也就是输入  然后输出 \n后来助教告诉我可以用异或，因为两次异或同一个就没了，与 0 异或可以赋值\n第二种方法更快一点\nTunnel 问题大量复制之后要检查 Tunnel 的标签是不是对的\n","categories":["CO"],"tags":["Logisim"]},{"title":"计组P2——学会当好的编译器","url":"/2025/10/21/COP2/","content":"MARS 编写 MIPS 汇编1.善用宏：\n.macro Name(%arg).end_macro\n\n使用参数的宏可以复用相似代码，让代码更简洁\n2.条件分支与循环控制：\n主要利用条件指令跳转，一定要注意转移方程（如i += 1），注意结束条件\ne = nextEdge[e]\n3.函数调用方法：\n使用 $sp 进行栈存储，需要注意后入先出，存储返回地址和可能会覆盖到的寄存器数据，保证返回时能够恢复到原来的样子\njal 指令可以链接到下一条指令（存储到 $ra）\nfunction:saveStack($ra)saveStack($t0)calculation……callSelf:jal functionreturn:readStack($t0)readStack($ra)jr $ra\n\n4.多维变量输入：\n都需要压成一维数组，建议用宏写 getAddress，保证地址计算方式一致的同时减少代码复制粘贴产生的冗余和错误\n5.格式化输入输出：\nF1 help 可以看 syscall 用法\nP2 题解01 迷宫核心思路：(这里我从 0 开始编号，和输入的起点终点编号有区别，注意区分)\nint fx[4] = {-1,1,0,0} , fy[4] = {0,0,-1,1};void dfs(int x,int y) {    mark[x][y] = 1;    if (x == goal_x &amp;&amp; y == goal_y) {        sum++;        mark[x][y] = 0;        return;    }    for(int i = 0 ; i &lt; 4 ; ++i) {        int next_x = x + fx[i];        int next_y = y + fy[i];        if(next_x &lt; 0 || next_y &lt; 0 || next_x &gt;= n || next_y &gt;= m) continue;        if(mark[next_x][next_y] == 1 || map[next_x][next_y] == 1) continue; //mark是已经走过，map是输入时的map        dfs(nx,ny);    }    mark[x][y] = 0;    return;}\n\ndebug注意：\n\nx 和 next_x 占的寄存器搞得不太清楚（直接写的原因），有条件最好还是先用 c 写 core function\nsw 和 lw 混用\n\n课上反思数组的写入最好用寄存器记首地址，然后写一个统一的save和load宏，方便一一对应\ne = nextEdge[e]\n","categories":["CO"],"tags":["MIPS","Mars"]},{"title":"计组理论","url":"/2025/12/02/CO/","content":"一、计算机组成概述（一）计算机组成与结构简介组成部分：\n\n运算器（数据处理） ALU + Registers\n存储器（数据存储）\nIO设备（数据交换）\n控制器（控制） Datapath + Control = CPU\n\n\n层次结构： 虚拟机器M3（高级语言程序）  虚拟机器M2（汇编语言程序） 虚拟机器M1（机器语言程序）\n总线结构\n（二）数的表示 进制表示 ：\n\n⚠️需要掌握进制转换的基本方式（短除法）\n下面着重讨论计算机中最重要的二进制：\n1. 有符号整数加法溢出： $${A|{31},A} + {B|{31},B} = temp.\\quad Overflow\\quad if\\quad temp[32]\\quad == \\quad temp[31]$$\n\n\n\n编码规则\n正数(7)\n负数(-7)\n\n\n\n原码\n符号位为0(0111)\n符号位为1(1111)\n\n\n反码\n不变(0111)\n符号位不变，其他取反(1000)\n\n\n补码\n不变(0111)\n反码+1(1001)\n\n\n求补码方法\n正数的原码反码补码均相同\n负数：\n原反补：\n补反原：补\n只对非符号位取反\n补码表示会比原码多一个  ，它占用的是原码中的 -0，且经过上述操作后仍得到原数\n引用原码以外的编码规则的原因：\n\n原码中 0 的表示不唯一和加减法方法不统一，需要为符号位单独设计硬件\n\n补码的理解:\n\n将负数按照大小关系拼接在 0 后，并且由于所谓的 -0 空置，相比于正数来说负数能多表示一个数例如-1(原码1001，补码1111，是最大的)\n\n2. 小数定点数：最高位作为整数部位，其余位作为小数部分(以 2 为基数)\n浮点数表示方法：\n其中  表示尾数，  表示阶数\n化为浮点数的方法：\n\n转化成二进制数\n对有效数位进行规格化，即小数点后第一位为 1 ，并记录相应的阶数\n整理符号\n\n\n\n\nJ0\nJ1J2J3……Jm\nS0\nS1S2S3……Sn\n\n\n\n阶符\n阶数数值\n数符\n尾数数值\n\n\n可能出现的问题：上溢（超过位数），下溢（接近 0，看作 0 处理）\nIEEE 754 标准 浮点数表示Float(32 bit)：\n\n\n\n数符 S\n阶码 E\n尾数 M\n\n\n\n1 位\n8 位\n23 位\n\n\nDouble(64 bit):\n\n\n\n数符 S\n阶码 E\n尾数 M\n\n\n\n1 位\n11 位\n52 位\n\n\n数符 S ：数的符号阶码 E：为正负指数统一，采用移码，即对于  位阶码，真实指数  编码指数值 （）尾数 M：规格化为 1.M 的形式，并且省略首位 1 ，减少存储所需位数\n单精度浮点数表示公式：\n双精度浮点数表示公式：\n3.非数值数据逻辑、格雷码、ASCII、汉字编码\n数据的检错：奇偶校验码、海明校验码、循环冗余校验码\n（三）计算机的工作过程机器指令：操作码 + 操作数（操作地址）\n程序：一段机器指令序列\n微操作：计算机可以完成的最基本操作\n冯.诺伊曼计算机的特点\n计算机由运算器、存储器、控制器和输入输出部分组成\n指令和数据用二进制表示，两者在形式上没有差别\n指令和数据存放在存储器中，按地址访问\n指令有操作码和地址码两个部分组成，操作码指定操作性质，地址码指定操作数位置\n采用“存储程序”方式进行工作\n\n二、组合逻辑电路（一）布尔代数与、或、非、异或……\n需要掌握化简和标准表达式（最小项和最大项）\n公理\n二值性\n，\n，\n$01=0，0+1=1，10=0，1+0=1$\n\n\n规则\n代入规则\n反演规则： 中的 交并交换、01交换、变量取反\n对偶规则：不用对变量取反的反演\n\n逻辑代数式化简\n合并同类项：\n吸收项法：\n配项法:\n\n卡诺图化简\n规则:\n\n每个圈包含  个 \n每个圈必须是矩形\n用最少的圈包住所有的 \n\n标准表达式将  称为基项，则（假设只考虑 ）\n最小项： 所有基项或其否定的积（如 ）\n最大项： 所有基项或其否定的和（如 ）\n标准化方法： 根据真值表可直接写出最小项表达式\n\n\n\nA\nB\nC\nF\n\n\n\n0\n0\n0\n0\n\n\n0\n0\n1\n1\n\n\n0\n1\n0\n0\n\n\n0\n1\n1\n0\n\n\n1\n0\n0\n0\n\n\n1\n0\n1\n1\n\n\n1\n1\n0\n1\n\n\n1\n1\n1\n1\n\n\n找到  为  的行\n可写出：\n（二）逻辑门电路略.（其实是因为懒得看）\n（三）组合电路的设计思路及常见示例基本思路： 逻辑问题  真值表  化简式  电路实现\n1. 半加器\n\n\nA\nB\nS\nC\n\n\n\n0\n0\n0\n0\n\n\n0\n1\n1\n0\n\n\n1\n0\n1\n0\n\n\n1\n1\n0\n1\n\n\n一眼盯真：\n全加器就是增加一位 Cin 作为进位\n串行进位:若将全加器直接串联得到串行进位加法器\n\n并行进位:若将  递归地拆解为 、 ，可以得到并行进位加法器\n2. 编码器 线  线编码器： \n只允许其中一个输入信号有效，输出对应有效输入的编号的二进制编码\n8421BCD编码器$^$：* \n用 4 位二进制，对 10 个十进制数字进行编码，其输出分别为 \n\n\n\n\n发现了什么？其实就是 1、2、4、8 对应位上是否为 1\n优先编码器： 为了解决只允许一个信号输入的问题，设定只输出优先级最高的信号对应的输出\n如 74LS147（）、74LS148（）\n3.译码器编码： 为区分一系列不同的事物，对其中的每个事物用一组二值（0或1）的二进制代码表示。\n译码： 将二进制代码所表示的信息翻译成对应高低电平信号输出的过程称为译码，译码是编码的反操作。\n基础款——变量译码器（二进制译码器）：即  线  线译码器 \n如  74138 （3-8译码器），这个要求使能信号 时才能工作\nBCD译码器、显示译码器 \n一定要看清楚是低有效还是高有效！！！\n(四) 多路选择器的应用常见多路选择器：如  选  多路选择器（74151）\n功能：\n\n多路选择（废话）\n逻辑函数生成\n\n逻辑函数生成指的是将逻辑基项作为地址数据，用多路选择器来输出逻辑函数值\n例如用 74151 实现 \n若以  为地址，可知  为 1，其余为 0\n变种：\n只允许用 4 选 2 选择器和非门，则把其中一些信号作为 Y 的输入，则：\n ，其余（其实只剩 ）为 0\n（五）电路中的竞争冒险现象核心原因： 门电路的延时\n竞争——挤着出门，冒险——挤着进门（输入突变会造成毛刺）\n判断方法：\n\n代数法：  对其他项赋特值，出现  \n卡诺图法： 两圈相切\n\n消除方法：\n\n修改逻辑设计——增加冗余项：将卡诺图相切部分用矩形圈起来（新增信号），不影响功能\n选通法——引入采样脉冲：直到稳定才放通，消除毛刺\n滤波法——输出端并联电容：不稳定的吸收掉，消除毛刺\n\n三、时序逻辑电路结构特点：由组合逻辑电路和存储电路构成\n锁存器和触发器1.RS锁存器R(Reset，置 0)，S(Set，置 1)\n非法状态（注意看具体实现）：不能同时置 0 又置 1\n特性方程： \n\n所谓钟控 RS 锁存器 ，就是在上述基本 RS 锁存器的前提下，R 和 S 必须在有效电平才输入（与门实现）\n2.D 锁存器所谓 D 锁存器，实际上是基于 钟控 RS 锁存器，将 R 端固定为 ，即输入  就是 \n特性方程： \n\n\n3.D触发器\n区别：\n\n锁存器：电平触发\n触发器：有效沿触发\n\n所谓 D触发器，实际上就是两个 D 锁存器 串联，接相反的时钟信号，则只有有效沿才能使得信号从 N1 写入 slave\n\n4. JK锁存器\n无所谓。\n事实上，我严重怀疑课件所给出的应该叫做 JK 锁存器，就是下面所给的图并不是边沿触发，而是电平触发\nJK = 钟控RS + （当R S 同时有效时，翻转输出状态）\nJ 对应 S（Set），K 对应 R（Reset），其命名是改进者的名字\n特性方程： \n\n其中（CP = 1） 可进一步化简为： \n有限状态机摩尔(Moore)型状态机： 输出信号仅与当前状态有关\n米里(Mealy)型状态机： 输出信号与当前状态及输入信号有关\n基本步骤：\n\n状态数建模：二进制编码、格雷码、独热编码\n画状态图：Moore在点内写输出，Mealy在边上写 输入/输出\n得逻辑表达式\n形成电路\n\n时序分析\n\n\n建立时间  (Setup Time)：触发时钟沿之前，输入必须稳定的时间\n保持时间  (Hold Time)： 触发时钟沿之后，输入仍需稳定的时间\n孔径时间 = ，输入信号在孔径时间内必须稳定不变\n（Clock-to-Q）时间  ：从触发时钟边沿到输出稳定的时间\n（Clock-Contamination-Q）时间 ：从触发时钟沿到输出端 Q 改变的最小延迟（污染延迟）\n\n限制条件：\n\n时钟周期  （ 指最长路径延时； 指时钟偏移，一般省略）\n满足  和  的定义\n最短路径\n\n我们分  和  来考虑这个问题，如下，注意，我们需要向  存的是“旧值”，即时钟沿前一个周期已经形成的稳定组合逻辑输出，但未被写入 \nR1时刻 (ps):      0         30(Tccq)            80(Tctq)                           |           |                   |时钟 CLK:       /¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯               ↑            (开始)输出 Q 的状态:  [  旧值 A  ] [ ? ? 变化中 ? ? ] [  新值 B  ]                ___________                      ___________波形示意:       ________A______X_变_化_区_域_X______B________                           ↑                   ↑                           |                   |               (Q1最早开始变化的时间)       (Q1最晚稳定下来的时间)                    Tccq = 30ps            Tctq = 80psR2时间轴:   0ps __________________ 55ps _____ 60ps __________           |                      |          |数据现状:  [      旧值 (稳定)      ] [ 新值来了 ]                                  ↑          ↑                          (实际数据变了)    (下一级要求必须保持到这里)\n\n时序逻辑电路设计与分析\n数据锁存器： 由多个锁存器组成的用于保存一组二进制代码的寄存单元\n数据寄存器： 由多个边沿触发器组成的用于保存一组二进制代码的寄存单元\n移位寄存器： 每一个时钟脉冲，寄存器中数据就依次向左或向右移一位。\n计数器： 可以统计输入脉冲个数的器件\n\nCT74194（4位双向移位寄存器）\n十进制加法计数器指的是计数循环的状态个数为10（也称模10计数器）\n异步计数器：输入系统时钟脉冲只作用于最低位触发器，高位触发器的时钟信号往往是由低一位触发器的输出提供的，高位触发器的翻转有待低一位触发器翻转后才能进行\n四、主存储器存储单元电路存储器分类\n\n按介质分类：\n\n\n半导体存储器（易失性）\n磁介质存储器（非易失性）\n光盘存储器（非易失性）\n\n\n按访问方式分类：\n\n\n随机访问存储器 （Random Access Memory—RAM）\n顺序访问存储器 （Tape）\n直接访问存储器 （Disk）\n只读存储器 （Read Only Memory—ROM）\n\n\n按功能分类：\n\n\n高速缓冲存储器（Cache）\n主存储器\n辅助存储器\n控制存储器\n\n主存储器的结构存储器的扩展DRAM的刷新五、指令系统与MIPS汇编语言本节主要考察对MIPS架构和指令集的熟悉程度，请直接查看指令集进行复习\nadd,addu,addi, addiu,sub, subu, mul, mulu, div, divu,mfhi,mflo,slt(小于设置1),sltu，and,andi,or,ori,xor(异或),xori,nor，sll,srl,sra,sllv,srlv,srav\n六、MIPS处理器设计理论方面主要考察处理器性能分析、冒险处理\n七、高速缓冲存储器1. 局部性原理**局部性原理 (Principle of Locality)**：大量典型程序的运行情况分析结果表明，无论是存取指令或存取数据，所访问的存储单元都趋于聚集在一个较小的连续存储区域中。\n\n时间局部性： 刚被访问过的单元不久后可能再次被访问（如循环指令）。\n空间局部性： 刚被访问过的单元的邻近单元可能不久被访问（如数组遍历）。\n\nCache 产生的背景：\n\n单级存储系统中，主存的存储速度与CPU的速度不匹配，造成CPU资源的浪费；\n程序运行时访问主存存在明显的局部性特征；\n存在比主存普遍采用的DRAM速度更快的存储单元电路\n\n2. Cache 的原理基本原理： 在CPU和主存间设置一容量较小的高速缓存，其中总是存放最活跃（被频繁访问）的程序块和数据，大多数情况下，CPU能直接从这个高速缓存中取得指令和数据，而不必访问主存。\n\n特点： 速度越快，成本越高，容量越小\n\nCache与主存之间以数据块（Block）为单位进行数据交换\n每个数据块包含若干个字或字节\nCache块大小和主存块大小相等\n\nCache要解决的问题：\n\n提供快速访问的能力；\n与主存交换数据的能力；\n由于CPU总是以主存地址访问存储器，所以Cache应具备判断CPU当前要访问的内容是否在Cache中的能力，并具有根据主存地址在Cache中访问相应单元的能力；\n具备在Cache容量不够的前提下替换Cache中的内容的决策能力。\n\nCache的基本结构\n\n存储机构： 保存数据，存取数据，一般采用SRAM构成。以数据块 Block（若干字）为单位，Cache块大小与主存块大小相同；\n地址机构：地址比较机制，地址转换机制，地址标记（Tag），一个Block具有一个Tag；\n替换机构：记录Block的使用情况，替换策略，有效位（v）记录对应数据块中的数据是否有效。\n\nCache的有关术语\n\n数据块（block）：Cache与主存的基本划分单位，也是主存与Cache一次交换数据的最小单位，由多个字节（字）组成，取决于主存一次读写操作所能完成的数据字节数，也表明主存与Cache之间局部总线的宽度。\n标记（tag）：每一 Cache 数据块有一个标记字段，用来保存该Cache数据块对应的主存数据块的地址信息。\n有效位（valid bit）：Cache中每一Block有一个有效位，用于指示相应数据块中是否包含有效数据。\n行（line）：Cache中 一个block及其 tag、valid bit构成1行。\n组（set）：若干块(Block)构成一个组，地址比较一般能在组内各块间同时进行。\n路（way）：Cache相关联的等级，每一路具有独立的地址比较机构，各路地址比较能同时进行（一般与组结合），路数即指一组内的块数。\n命中率（hit rate）：目标数据在Cache中的存储访问的比例。\n缺失率（miss rate）：目标数据不在Cache中的存储访问的比例\n\n\n 计算 Cache 实际容量： \n不作特殊申明时，Cache的容量指所有Cache数据块的总容量，实际容量还包括含 tag 和 valid bit 等的位数\n设 Cache 有  组，每组  行，每行有  个字节数据，则 \ncache 容量 = \n3. Cache的映射机制主要原因：Cache的块比主存块少\n主要机制： 全相联映射、直接映射、组相联映射\n\n\n\n机制\n地址格式\n地址格式\n地址格式\n说明\n\n\n\n全相联\nBlock Number (Tag)\nOffset\n\n只看Block number\n\n\n直接\n区地址 (Tag)\n区内块地址(Index)\nOffset\nK ＝ J Mod M（将主存第 J 块映射到 Cache 第 K 块，M 为 Cache 块数）\n\n\n组相联\n组内块地址(Tag)\n组地址(Set)\nOffset\nCache 分成 K 组，每组分成 L 块；主存的块 J 以下列原则映射到 Cache 的组 I 中的任何一块。I = J mod K\n\n\n\n\n\n常见问题：\n\n主存和Cache各分多少块？\n主存地址的位数是多少？ 格式是什么？\nTag需要多少位？\n若采用组相连模式，Cache分多少组？每组包含多少块？主存分多少组？每组包含多少块？\n\n主存容量 16M 字节，Cache容量 64K 字节，Block大小 16 Bytes，采用 4路组相联（每组包含4个Block）\n主存块数：Cache块数：全相联：20（主存块地址Tag） + 4（块内地址）直接：8（20 - 12 = 8，区地址Tag） + 12 （区内块地址） + 4（块内地址）Cache组数：主存每组块数：（将主存分成  组）组相联：10（组内块地址Tag） + 10（组地址） + 4（块内地址）\n优缺点比较：\n\n\n\n机制\n优点\n缺点\n\n\n\n全相联\n灵活使用Cache\n在执行Cache读写操作时，块地址要与Cache中所有Tag都比较\n\n\n直接\n只需与块地址对应的 Tag 进行1次比较\n映射关系不灵活，Cache空间的利用不充分\n\n\n组相联\n折衷\n折衷\n\n\n4.替换机制缺失损失： CPU访问Cache缺失时，CPU必须等待数据装入Cache后才能访问Cache，这期间的时间损失称为缺失损失\n取出块的时间： 第一个字的延迟时间（存储器访问）+ 块的剩余部分的传送时间\n缺失处理（以读操作为例，写操作比较复杂）\n\n块装入后访问：缺失数据块中各字按顺序全部装入Cache后，再从Cache中访问所请求的字（也即引起缺失的字）\n尽早重启（early restart）：缺失数据块中各字按顺序装入 Cache，一旦所请求的字装入 Cache ，CPU立即访问该字，控制机构再继续传送剩余数据到 cache \n请求字优先（requested word first）：所请求的字先装入 Cache，CPU立即访问该字，控制机构再按照先从所请求字的下一个地址、再到块的起始地址的顺序继续传送剩余数据到 cache\n\n\n替换块的选择范围\n\n直接映射：访问缺失时，被请求数据所在块，只能进入 Cache 的一个位置，原来占用该位置的数据块必须被替换掉\n组相联：访问缺失时，被请求数据所在块，可进入 Cache 某一组的任何位置，因此，应在 Cache 对应组内选择一个数据块进行替换\n全相联：访问缺失时，被请求数据所在块，可进入 Cache 的任何位置，因此，可在 Cache 中任选一个数据块进行替换\n\n替换策略\n\n最近最少使用法（LRU，Least-Recently Used）：记录每一个数据块的相对使用情况，最近没有被使用的块被替换。\n先进先出法（FIFO，First-In-First-Out）：最先装入数据的块被替换；\n最小使用频率法 （LFU，Least-Frequently Used）：记录每一个数据块的使用频率，使用次数最少的被替换。\n随机法（RAND，Random）：随机选择一个数据块进行替换\n\n实现方法\nLRU（计数器法）\n\nCache的每一块都设置一个计数器；\n被调入或被替换的块，其计数器清 0，而其它的计数器则加 1；\n访问命中时，所有块的计数值与命中块的计数值进行比较：（1）如果计数值小于命中块的计数值， 则该块的计数值加 1；（2）如果块的计数值大于命中块的计数值，则数值不变。最后将命中块的计数器清为0。\n需要替换时，则选择计数值最大的块来替换。\n\n理解：只需要保证相对大小即可，所以为了防止无限增长做了区分\nFIFO（计数器法）\n\n例如Solar－16/65机Cache采用组相联方式，每组4块，每块都设定一个两位的计数器\n当某块被装入或被替换时，该块的计数器清为0，而同组的其它各块的计数器均加1\n当需要替换时就选择计数值最大的块被替换掉\n\n5. Cache性能分析存储访问时间 = 访问命中率主存访问命中率\n加速比SP = 存储访问时间主存访问周期\n数据一致性的问题主要由写操作产生\n\n写通过（写直达，Write Through）：写Cache的同时写主存，效率较低；\n写回（Write Back）：写操作只更新Cache中的数据，直到Block替换时才将整个Block写回主存，一般使用“脏位”（dirty bit）来表示Block在替换回主存之前是否被修改过。\n\n块的大小与命中率关系\n\n一般而言，增加块大小将降低缺失率（因为空间局部性）\n但块大小达到一定程度时，缺失率会随块大小的继续增加而上升（因为Cache总容量限制，块数量会下降，导致块替换增加）；\n单纯增加块大小带来缺失代价（缺失损失）的增大。\n\n八、虚拟存储系统（一）辅助存储器辅助存储器\n\n定义：主存的后援设备，不直接与CPU交换信息，又称外存\n分类：磁表面存储器（硬盘、软盘、磁带）、光介质存储器（光盘）\n特点：容量大、价格低、非易失性、速度慢\n\n1.磁表面存储器：磁介质（通过磁化方向记录 01） + 磁头（向线圈提供电流，磁头体被磁化，成为信息源）\n等角速度\n磁记录编码方式：实际上是写入电流的变化方式,即按什么规律，把一连串的二进制信息变换成磁层中的一个序列的磁化翻转状态，且能可靠地用读写电路实现这一转换过程\n主要分类：归零制RZ(正负脉冲电流)、不归零制NRZ(正反向电流)、调相制PM(磁化翻转方向)、调频制FM(磁化翻转频率)\n\n评价磁记录编码方式的主要指标\n\n编码效率：记录一位信息的最大磁化翻转次数的倒数；FM与PM为 2（50%），NRZ为 1（100%）\n自同步能力：能否直接从读出的信号中提取同步信号；NRZ没有自同步能力，PM，FM等都具备自同步能力\n可靠性：归零制低，调相制高\n\n\n  \n    \n      理解：\n\n    \n    \n      编码效率高 &lt;-&gt; 翻转次数少，单位长度存的位数多\n自同步能力强 &lt;-&gt; 能从读出的信号中恢复时钟，抗干扰能力强\n\n    \n  \n\n硬磁盘存储器的基本结构 = 磁盘控制器 ＋ 磁盘驱动器（盘片）\n\n\n性能分析\n记录密度：\n\n道密度：磁盘沿半径方向单位长度的磁道数\n位密度：单位长度磁道记录二进制的位数\n\n存储容量 = 盘面数磁头数每盘面的磁道数每磁道的扇区数扇区容量\n访问时间（也称寻址时间）： \n\n寻道时间 TS：磁头从当前位置定位到目标磁道所需时间（平均值）\n寻区时间 Tw：磁头定位到目标磁道后，等待目标扇区旋转到磁头下所需的时间（平均值，通常按半圈算，可以理解为等可能选中所有扇区时期望为转半圈）\n\n数据传输率 ：单位时间内传输的数据位数（b/s）\n【典例】 假设磁盘存储器共有 6 个盘片，最外两侧盘面不能记录，每面有 204 条磁道，每条磁道有 12 个扇段，每个扇区有 512Bytes ，磁盘以 7200rpm 速度旋转，平均寻道时间为 8ms ，计算该磁盘存储器的：（1）容量（2）平均寻址时间（3）数据传输率\n\n  \n    \n      note：\n\n    \n    \n      (1) \n(2) \n(3) （）\n\n    \n  \n\n磁盘类型（？不知道是否需要掌握）？？？？？？？\n2.光盘存储器\n？？？？？？？？？\n（二）虚拟存储系统\n1.虚拟存储器的调度方式:\n\n页式调度：将虚存空间和物理地址空间都分成固定大小的页。内存按页顺序编号；每个独立编址的程序空间也按自己的页顺序编号。虚存空间和物理空间按页进行交换。\n段式调度：把物理空间分成页；按程序的逻辑结构将程序空间划分为若干段，段的长度是随意的，虚存空间和物理空间按段进行交换。\n段页式调度：上述两种方法的结合。把物理空间分成页；程序按模块先分段，每个段再分成与物理空间页同样大小的页面。虚存空间和物理空间按页进行交换。\n\n2.页式虚拟存储器\n虚地址格式（逻辑地址格式）：虚页号 ＋ 页内地址\n实地址格式（物理地址格式）：实页号 ＋ 页内地址\n页表：记录虚页与实页的映射关系，实现虚实地址的转换，页表建立在内存中，操作系统为每道程序建立一个页表。页表用虚页号作为索引，页表项包括虚页对应的实页号和有效位\n\n【典例】 某计算机虚拟地址32位，物理内存128MB，页大小4KB。（1）程序虚拟空间最多可有多少页？（2）页表项共有多少位？（3）每个页表占多少内存空间？\n\n  \n    \n      note：\n\n    \n    \n      (1) ，12 位作为页内地址，最多可以有  页\n(2) 实页：，加上有效位，共 16 位\n(3) \n\n    \n  \n\n3.快表TLB\n总而言之，就是存储页的Cache\n\n问题：每次虚拟存储器的访问带来两次存储器访问，一次访问页表，一次访问所需的数据（或指令），简单的虚拟存储器速度太慢\n解决办法： 使用Cache存储部分活跃的页表项，称为TLB（快表），它包含了最近使用的那些页表项\nTLB内容：虚页号（标记）、对应实页号（数据）、有效位、修改位\nTLB一般采用全相联模式\n\n九、总线与输入输出方式总线总线： 一组公共的信号通道\n\n在某一时刻，只允许有一个部件向总线发送信息，而多个部件可同时从总线上接收相同的信息\n总线实际上是由许多传输线或通路组成，每条线可传输一位二进制码，一串二进制代码可以在一段时间内逐一传输。若干条传输线可同时传输若干位二进制代码\n\n总线片内总线：内部的总线系统总线：、主存、部件（接口）之间传递信息的公共通道通信总线：用于计算机系统间或计算机系统与其它系统间的通信\n系统总线又分为：数据总线、地址总线、控制总线\n性能指标:\n\n总线宽度：指数据总线的位数（根数），如32位，64位。\n标准传输率：每秒传输的最大字节量(B/s)，与总线宽度和频率相关\n同步/异步方式：总线上的数据与时钟同步工作的总线为同步总线，与时钟异步的总线为异步总线。\n信号线数：所有信号线的总数。\n总线控制方式：指总线上各部件使用总线的仲裁方式。\n总线复用：地址总线与数据总线是否复用（时分多路复用）。\n\n【典例】 设一个32位微处理器配有16位的外部数据总线，时钟频率为50MHz，若最短的总线传输周期为4个时钟周期，问处理器的最大数据传输率是多少？若想提高一倍数据传输率，可采用什么措施？\n补充~~~~~~~~~~~~~~~~~~~~~~~~~\n\n总线的一次信息传送过程，大致可分五个阶段：\n\n请求总线：由需要使用总线的部件或设备，提出总线使用申请\n总线仲裁：仲裁器决定下一传输周期的总线使用权是否授予该部件或设备\n寻址:获得总线使用权的部件或设备，发出地址和有关命令\n信息传送：进行数据传输\n状态返回：该部件或设备有关信息从总线上撤除，让出总线使用权\n\n","categories":["CO"],"tags":["理论"]},{"title":"计组P1——Verilog 和 状态机","url":"/2025/10/14/COP1/","content":"FSM 设计思路\n状态逻辑图\n状态化简\n状态编码\n状态转移（包含复位逻辑）\n输出逻辑\n\n课下省流\nop != Op\n多目运算符作为表达式，各部分符号会影响\n灵活运用位拼接符实现符号扩展：{{16{imm[15:15]}},imm[15:0]}\nposedge clk or posedge clr (right)\n\n课上卷积急中生智用vscode替换代码，写了个超巨大，主要是不懂怎么在Verilog里面用循环，和第二题坐一桌\n音符记录维护支持四种操作的队列（大小为128，初始为全3’b000）：\n2’b00；添加一个数到末尾2’b01：查询特定位置的数2’b11：输出某个数出现次数2’b10：维持输出\nreg [2:0] queue [127:0];integer i;for(i = 0 ; i &lt; 128 ; i = i + 1) begin    ……end\n\njson匹配Moore机，注意输出的时间点在读到 “}” 后转移状态就已经改变输出了\n还有注意不要忘了空集的转移\n","categories":["CO"],"tags":["Verilog"]},{"title":"计组P3——单周期CPULogisim实现","url":"/2025/10/28/COP3/","content":"最终展示\n设计草稿指令分析(数据通路)\n\n\nInstruction\nPC_next\nReg1\nReg2\nWreg\nwdata\nALU_A\nALU_B\nDM_Adr\nDM_wdata\nEXT\n\n\n\nadd\nPC+4\nrs\nrt\nrd\nALU\nReg1\nReg2\n-\n-\n-\n\n\nsub\nPC+4\nrs\nrt\nrd\nALU\nReg1\nReg2\n-\n-\n-\n\n\nori\nPC+4\nrs\n-\nrt\nALU\nReg1\nEXT\n-\n-\nzero(imm16)\n\n\nlw\nPC+4\nrs\n-\nrt\nDM_out\nReg1\nEXT\nALU\n-\nsign(imm16)\n\n\nsw\nPC+4\nrs\nrt\n-\n-\nReg1\nEXT\nALU\nReg2\nsign(imm16)\n\n\nbeq\nPC+4(f) or PC+4+EXT(t)\nrs\nrt\n-\n-\nReg1\nReg2\n-\n-\nsign(imm16&lt;&lt;2)\n\n\nlui\nPC+4\n-\n-\nrt\nEXT_Hi\n-\n-\n-\n-\n不影响(imm16)\n\n\nnop\nPC+4\n-\n-\n-\n-\n-\n-\n-\n-\n-\n\n\njr\nReg1\nrs\nrt=0\nrd=0\n-(ALU)\nReg1\nReg2\n-\n-\n-\n\n\n\n  \n    \n      注意：\n\n    \n    \n      \nnop为空指令(0x00000000)，不进行任何有效行为（修改寄存器等）\nadd,sub 按无符号加减法处理（不考虑溢出）  （个人认为这里应该是说按照有符号的码位，但是按无符号处理）\n由于 jr 可以和 add 、 sub 兼容，即使对 $0 写入也不会发生改变，因此这里进行了合并\n\n\n    \n  \n\n模块制作1. IFU（取指令单元）\n\n\nname\nI/O\nfunction\n\n\n\nreset\ninput\n异步复位\n\n\nclk\ninput\n时钟\n\n\nWE\ninput\n写入信号\n\n\nwdata[31:0]\ninput\n写入数据\n\n\nInstr[31:0]\noutput\n输出指令\n\n\npc[31:0]\noutput\n输出pc计数值\n\n\nPC 的起始位置为：0x00003000 ，但 ROM 的起始地址为 0x00000000 ，其实只影响 wdata 和 pc 两个位置，在内部可以仍然从 0 开始。\n注意：参考指令集，bge(t)时写入 PC + 4 + wdata\n根据数据通路可得到其内部结构：\n上表废弃，实践发现如果需要添加别的跳转指令，很难用单一的wdata表示，因此选用输入所有信号在IFU内部进行处理\n\n\n  \n    \n      勘误：\n\n    \n    \n      \nLogisim 的 ROM 地址是1、2、3，所以说应该 % 4 得到地址，但外部表现仍然是 + 4。\noffset就是偏移量，不需要减0x00003000\njr取出的地址是表地址，要化作内地址需要减偏移量\n\n\n    \n  \n\n2. GRF\n\n\nname\nI/O\nfunction\n\n\n\nreset\ninput\n异步复位\n\n\nclk\ninput\n时钟\n\n\nReg1[4:0]\ninput\n读1\n\n\nReg2[4:0]\ninput\n读2\n\n\nWreg[4:0]\ninput\n写\n\n\nwdata[31:0]\ninput\n写入数据\n\n\nWE\ninput\n写入信号\n\n\noutput1[31:0]\noutput\n读出1\n\n\noutput2[31:0]\noutput\n读出2\n\n\n需要注意 $0 总保持 0，采用 4 * 8 排线，用译码器解出写入寄存器的行列，用标号tunnel输出\n每个单元如下：\n\n写入信号与Wreg的行列信号 and 后的到的指定寄存器\n\n  \n    \n      注意：\n\n    \n    \n      $0 总保持 0，复用时需要检查标号是否正确\n\n    \n  \n\n整体如下：\n\n3. ALU\n\n\nname\nI/O\nfunction\n\n\n\nA[31:0]\ninput\n操作数A\n\n\nB[31:0]\ninput\n操作数B\n\n\nALUOp[2:0]\ninput\n运算信号\n\n\noutput[31:0]\noutput\n输出\n\n\nlogic\noutput\n逻辑输出\n\n\n本次初始指令集需要由 add、sub、or、equal种运算，为了可扩展性，选择编码ALUOp 为 3 位，即（更新：补充逻辑左移sll）\n\n\n\noperation\nALUOp\n\n\n\nadd\n000\n\n\nsub\n001\n\n\nor\n010\n\n\nequal\n011\n\n\nsll\n100\n\n\n结构如下：\n\n4. DM使用 RAM 即可，接入异步复位信号\n更新：提高可拓展性，分出信号选择区\n\n5. EXT使用 16-32EXT即可，注意后接逻辑左移，指向可能的跳转分支\n\n\n  \n    \n      勘误：\n\n    \n    \n      看清楚指令集中是signExt还是ZeroExt\n\n    \n  \n勘误：\n6.Controller根据数据通路表可以得到下图：\n\n第一次在这里犯了个错误，不是R指令才是写入rt。\n从中总结需要的控制信号有：not(Rinstr?)、RegWrite、ALUEXT?、RegChoose、ALUOp、MemWrite\n根据func可做Rdecoder(采用独热编码选择):\n\n根据信号连成下图：\n\n\n  \n    \n      Note：\n\n    \n    \n      可以看到Rdecoder和Controller都是六位译码，排线时可以复制左边，节约时间\nEXT勘误：注意符号扩展和零扩展，这里增加一个选扩展信号\n\n    \n  \n\n测试方案1.ori 和 sw先测试这两个的原因是main运行的时候没办法查看子电路内部，不过我的RAM是在main电路，通过这样的转换就可以查看grf的内部信息\n然后写了个 py 程序快速生成 32 个寄存器的查看（顺便检查一下有没有连错电路的）\nfor i in range(0,32):    print(f\"ori ${i},$0,{i}\")    print(f\"sw ${i},(${i})\")\n\n嗯果不其然第四行确实是连错了，行线连的第三行的\n补充：\n其实是可以右键子电路查看的\n另外Logisim的RAM一个格子对应的是 4 word，所以上面这个程序写错了，而且sw要求偏移量能被 4 整除，所以整理如下：\nfor i in range(0,32):    print(f\"ori ${i},$0,{i}\")    print(f\"add ${i},${i},${i}\")    print(f\"add ${i},${i},${i}\")    print(f\"sw ${i},(${i})\")\n\n2. 混合测试1使用以下教程提供的代码，使用它生成机器码，但是由于不考虑溢出，所以对拍数据用对应的addu查看\nori $a0, $0, 123ori $a1, $a0, 456lui $a2, 123            # 符号位为 0lui $a3, 0xffff         # 符号位为 1ori $a3, $a3, 0xffff    # $a3 = -1add $s0, $a0, $a2      # 正正add $s1, $a0, $a3      # 正负add $s2, $a3, $a3      # 负负ori $t0, $0, 0x0000sw $a0, 0($t0)sw $a1, 4($t0)sw $a2, 8($t0)sw $a3, 12($t0)sw $s0, 16($t0)sw $s1, 20($t0)sw $s2, 24($t0)lw $a0, 0($t0)lw $a1, 12($t0)sw $a0, 28($t0)sw $a1, 32($t0)ori $a0, $0, 1ori $a1, $0, 2ori $a2, $0, 1beq $a0, $a1, loop1     # 不相等beq $a0, $a2, loop2     # 相等loop1:sw $a0, 36($t0)loop2:sw $a1, 40($t0)\n\n检查出分支可能有问题，下面测试分支，检查后实现对IFU的勘误2\n3.混合测试2v2.0 raw341c0000341d000034013456002108208c010004ac0100043c027878004118223c0512343404000500000000ac85ffff8c83ffff106500011000000d3467040410e3000b000000003c0877773508ffff000800223400110000e650203408000034090001340a0001010a40201109fffe1000ffff\n\n转换成MIPS代码如下：\nori $28,$0,0ori $29,$0,0ori $1,$0,13398add $1,$1,$1 lw $1,4($0)sw $1,4($0)lui $2,30840sub $3,$2,$1lui $5,4660ori $4,$0,5nopsw $5,-1($4)lw $3,-1($4)beq $3,$5,nextbeq $0,$0,endnext:ori $7,$3,1028beq $7,$3,endnoplui $8,30583ori $8,$8,65535sub $0,$0,$8ori $0,4352add $10,$7,$6ori $8,$0,0ori $9,$0,1ori $10,$0,1uu:add $8,$8,$10last:beq $8,$9,uuend:beq $0,$0,end\n\n4.混合测试3ori $0,$0,72ori $1,$0,1ori $2,$0,2ori $3,$0,3ori $4,$0,4ori $5,$0,5ori $6,$0,6ori $7,$0,7ori $8,$0,8ori $9,$0,9ori $10,$0,10ori $11,$0,11ori $12,$0,12ori $13,$0,13ori $14,$0,14ori $15,$0,15ori $16,$0,16ori $17,$0,17ori $18,$0,18ori $19,$0,19ori $20,$0,20ori $21,$0,21ori $22,$0,22ori $23,$0,23ori $24,$0,24ori $25,$0,25ori $26,$0,26ori $27,$0,27ori $28,$0,28ori $29,$0,29ori $30,$0,30ori $31,$0,31lui $t1,0xffffori $t1,$t2,0xffffori $sp,$0,0loop:beq $t0,$31,nextsub $s1,$s2,$s3add $s3,$t0,$t6ori $t3,$t2,1000lui $5,0xabcdnopsw $t0,0($sp)add $sp,$sp,$4sw $t0,0($sp)lw $s2,-4($sp)nopadd $t0,$t0,$1beq $0,$0,loopnext:noplui $7,100\n\n为了检测输出，我模仿Pre和P0教程出现的测试电路，搭建出test：\n\n该测试方法需要与其他CPU对拍，这里我在双方均通过weak的情况下交换CPU测试，不建议一方未完成进行这种行为，只作学习参考使用。\n5.测评机对拍参考了COT进行测试，以下只是使用日记，参考价值不大。\n上来就报错：AttributeError: 'str' object has no attribute 'keys'\n先根据AI的提示，把：\n# 先设置基本属性self.__set_attr(file_config)if not self.__lazy:    file_config = self.__format_set(file_config)\n\n改成了\n# 先设置基本属性self.__set_attr(file_config)# 如果是非懒人模式，格式化设置并重新设置属性if not self.__lazy:    file_config = self.__format_set(file_config)    self.__set_attr(file_config)  # 重新设置格式化后的属性\n\n然后需要根据指南填写config，由于只是测简化指令，最好还是根据需求填config而不是用lazy mode。\n但是他给的 cpu 貌似在 logisim 运行的时候有问题，不知道是不是因为简化指令的锅，我在查看dif log的时候以为自己哪做错了，浪费了半天，才发现自己的cpu是叫mycpu而不是cpu（晕）\n其实不能过度依赖，毕竟和实际的评测环境还是有区别的，但是看到自己设计的cpu确实经过大规模数据测试Accepted还是有点小开心的\n扩展尝试鸽鸽鸽\n留好端口方便实现。\n思考题1. 第一题\n上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。\n\n上游（Moore机）：PC存储状态，输出取指令地址，经过跳转单元（若无跳转则为与 4 Add）得到下一次状态。\n下游（Mealy机）：可以理解为通用寄存器堆（GRF）作为状态存储单元，由指令（经过spiltter处理）作为输入信号（经过Controller生成控制信号形成最终的输入信号），控制着从GRF取值、控制ALU输出值，而写入信号与输出值共同控制状态转移\n2.第二题\n现在我们的模块中 IM 使用 ROM，DM 使用 RAM，GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。\n\n合理，IM在程序运行过程不会修改，所以选择ROM，而DM需要支持读出和写入，选择RAM，二者都需要多地址存储。而GRF是通用寄存器堆，用Register更方便，也更容易改装（如对$0始终保持0的改装）。\n3.第三题\n在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。\n\n我实现了Rdecoder，其功能是针对R型指令将func码转化成对应的ALUOp，具体细节参考上文Controller部分，补充下设计思路：使用和Controller类似的与门阵列，在连线时将输入调整成111111，可以降低连错的概率\n4.第四题\n事实上，实现 nop 空指令，我们并不需要将它加入控制信号真值表，为什么？\n\n因为nop不对任何存储单元操作（PC是自增，即使没有nop也会进行），因此nop没有相对应的控制信号\n5.第五题\n阅读 Pre 的“MIPS 指令集及汇编语言”一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。\n\n挺强的\n覆盖情况：缺少sub和nop，没有实现全覆盖\n测试强度：\n(1) I型指令：lui已经得到充分测试，但ori没有涉及检查0扩展和sign扩展（唯一一次用的是和0xffff0000，两种扩展结果相同），因此可以增加相应指令。lw 和 sw 有涉及，但是没有考虑 offset 为负数的情况，混合测试 2 中包含了这一点同样的，beq没有涉及 offset 为负数的情况，因此我考虑用 beq $0,$0,back 来检查是否能正常回溯。(2) R型指令：由于 add 和 sub 只考虑无符号，因此直接加减即可。\n附录指令集\n\n\n\n\n\n\n","categories":["CO"],"tags":["Logisim","单周期CPU"]},{"title":"计组P4——单周期CPU的verilog实现","url":"/2025/11/05/COP4/","content":"课上回忆1.brc计算指令(标准 R 型指令) &#x3D;》 add、sub\ntemp &lt;- GPR[rs] [4:0]if (temp &lt;&#x3D; 24 &amp;&amp; countones(GPR[rt] [temp+7:temp]) mod 2 &#x3D;&#x3D; 0):    GPR[rd] &lt;- reverse(GPR[rt])else:    GPR[rd] &lt;- GPR[rt]\ndef countones(x):数 x 二进制表示中有多少个 1def reverse(x):对 x 位翻转\n思路：新功能可以集成到 ALU 中，无需增加数据通路，但笔者对两个位操作没有很简洁的做法，ctrl + c v ，十分丑陋\n2.cabc分支指令 &#x3D;》 beq\ntemp1 &lt;- {GPR[rs] [15:8],GPR[rs] [7:0],GPR[rt] [31:24],GPR[rt] [23:16]}temp2 &lt;- {GPR[rs] [31:24],GPR[rs] [23:16],GPR[rt] [15:8],GPR[rt] [7:0]}xor_result &lt;- temp1 ^ temp2if (countzeros(xor_result[31:16]) &#x3D;&#x3D; countzeros(xor_result[15:0])):    PC &lt;- PC + 4 + signext(offset||2’b00)else :    GPR[rt] &lt;- xor_result    PC &lt;- PC + 4\n思路：分支跳转方式和 beq 完全一致，不一样的地方在于可能需要写入 grf ，因此要加信号控制写入，我选择由 controller 的控制信号和 alu 发出的 logic 共同决定是否写入\n同样还是位运算太丑陋了，但是整体数据通路调整不多\n注意： 拼接方式可能有误，但是差不多如此，不影响整体思路\n3.lhboc访存指令 &#x3D;》 lw\n前面整体和 lw 一致，只是写入 grf 时根据读出的 memword 不同，写入的 data 也会不同\n思路：前面完全照抄 lw ，给 grf 接一个特殊的 mode ，然后进行计算即可\n注意： 2、3添加信号记得给其他所有的信号default\n设计草稿总体设计图如下：\nerDiagram\n    mips {\n        input clk\n        input reset\n    }\n    mips ||--o{ pc : clk_rest\n    mips ||--o{ grf : clk_rest\n    mips ||--o{ mem : clk_rest\n\n\n    pc {\n        input clk\n        input reset\n        input[31_0] npc\n        output[31_0] adr\n    }\n\n    pc ||--o{ npc : adr\n    pc ||--o{ im : adr\n    pc ||--o{ muxGrfWdata : adr\n    pc ||--o{ grf : adr\n    pc ||--o{ mem : adr\n\n\n    npc {\n        input logicOutput\n        input[2_0]  mode\n        input[31_0] pc\n        input[31_0] immSignExt\n        input[25_0] instr_index\n        input[31_0] aluOut\n        output[31_0] npc\n    }\n\n    npc ||--o{ pc : npc\n    \n\n    im {\n        input[31_0] adr\n        output[31_0] instr\n    }\n\n    im ||--o{ spilter : instr\n\n    spilter {\n        input[31_0] instr\n        output[31_26] opcode\n        output[25_21] rs\n        output[20_16] rt\n        output[15_11] rd\n        output[10_6] shamt\n        output[5_0] func\n        output[15_0] imm\n        output[25_0] instr_index\n    }\n\n    spilter ||--o{ controller : opcode_func\n    spilter ||--o{ muxGrfRd1 : rs\n    spilter ||--o{ muxGrfRd2 : rt\n    spilter ||--o{ muxGrfWt : rd\n    spilter ||--o{ muxGrfWt : rt\n    spilter ||--o{ ext : imm\n    spilter ||--o{ npc : instr_index\n\n    controller {\n        input[5_0] opcode\n        input[5_0] func \n    }\n\n    controller ||--o{ muxGrfRd1 : rd1Choose\n    controller ||--o{ muxGrfRd2 : rd2Choose\n    controller ||--o{ muxGrfWt : wtChoose\n    controller ||--o{ muxGrfWdata : wdataChoose\n    controller ||--o{ muxA : AChoose\n    controller ||--o{ muxB : BChoose\n    controller ||--o{ muxMemAdr : memAdrChoose\n    controller ||--o{ muxMemWdata : memWdataChoose\n    controller ||--o{ alu : aluOp\n    controller ||--o{ grf : grfWE\n    controller ||--o{ mem : memWrite\n    controller ||--o{ npc : mode\n\n    muxGrfRd1 {\n        input[2_0] rd1Choose\n        input[5_0] rs\n        output[5_0] rd1\n    }\n\n    muxGrfRd1 ||--o{ grf : rd1\n\n    muxGrfRd2 {\n        input[2_0] rd2Choose\n        input[5_0] rt\n        output[5_0] rd2\n    }    \n\n    muxGrfRd2 ||--o{ grf : rd2\n\n    muxGrfWt {\n        input[2_0] wtChoose\n        input[5_0] rd\n        input[5_0] rt\n        output[5_0] wt\n    }    \n\n    muxGrfWt ||--o{ grf : wt\n\n    muxGrfWdata {\n        input[2_0] wdataChoose\n        input[31_0] aluOut\n        input[31_0] memOut\n        input[31_0] pc\n        output[31_0] wdata\n    }\n\n    muxGrfWdata ||--o{ grf : wdata\n\n    grf {\n        input clk\n        input reset\n        input[4_0] rd1\n        input[4_0] rd2\n        input[4_0] wt\n        input WE\n        input[31_0] wdata\n        input[31_0] wPc\n        output[31_0] rdata1\n        output[31_0] rdata2\n    }\n\n    grf ||--o{ muxA : rdata1\n    grf ||--o{ muxB : rdata2\n    grf ||--o{ muxMemWdata : rdata2\n\n\n    alu {\n        input[5_0] aluOp\n        input[31_0] A\n        input[31_0] B\n        output[31_0] output\n        output logicOutput\n    }\n\n    alu ||--o{ muxGrfWdata : aluOut\n    alu ||--o{ muxMemAdr : aluOut\n    alu ||--o{ npc : aluOut\n    alu ||--o{ npc : logicOutput\n\n    muxA {\n        input[2_0] Achoose\n        input[31_0] GPR[rs]\n        output[31_0] A\n    }\n\n    muxA ||--o{ alu : A\n\n    muxB {\n        input[2_0] Bchoose\n        input[31_0] GPR[rt]\n        input[31_0] immZeroExt\n        input[31_0] immSignExt\n        output[31_0] B\n    }\n\n    muxB ||--o{ alu : B    \n\n    muxMemAdr {\n        input[2_0] memAdrChoose\n        input[31_0] aluOut\n        output[31_0] memAdr\n    }\n\n    muxMemAdr ||--o{ mem : memAdr\n\n    muxMemWdata {\n        input[2_0] memWdataChoose\n        input[31_0] GPR[rt]\n        output[31_0] memWdata\n    }\n\n    muxMemWdata ||--o{ mem : memWdata\n\n    mem {\n        input clk\n        input reset\n        input[31_0] memAdr\n        input memWrite\n        input[31_0] wdata\n        input[31_0] wPc\n        output[31_0] memOut\n    }\n\n    mem ||--o{ muxGrfWdata : memOut\n\n    ext {\n        input[15_0] imm\n        output[31_0] immSignExt\n        output[31_0] immZeroExt\n    }\n\n    ext ||--o{ muxB : immZeroExt\n    ext ||--o{ muxB : immSignExt \n    ext ||--o{ npc : immSignExt\n\n总的来说，摒弃了P3中权责暧昧的设计，将所有控制信号完全交由controller进行控制，其他模块只管根据选择信号进行相应操作即可\n模块设计mux为了便于扩展，每个选择器都设置为三位选择信号，由controller统一发出\npc and im\n\n\ndef\nname\n\n\n\ninput\nclk\n\n\ninput\nreset\n\n\ninput[31:0]\nnpc\n\n\noutput[31:0]\npc\n\n\n@ posedge clk     if reset == 1:        pc &lt;= 32&#x27;h00003000    else:        pc &lt;= npc\n\nim需要注意：\nreg [31:0] im_reg [0:4095]; //4096个元素，每个元素是32位，注意数组大小是从小到大initial begin    $readmemh(&quot;code.txt&quot;, im_reg);endassign id = adr - 32&#x27;h00003000;assign instr = im_reg[id[31:2]];\n\nnpc\n\n\ndef\nname\n\n\n\ninput\nlogicOut\n\n\ninput[2:0]\nmode\n\n\ninput[31:0]\npc\n\n\ninput[31:0]\nimmSignExt\n\n\ninput[25:0]\ninstr_index\n\n\ninput[31:0]\naluOut\n\n\noutput[31:0]\nnpc\n\n\n\n\n\nmode\nfunction\nrelevant\n\n\n\n000\nnpc &#x3D; pc + 4\n-\n\n\n001\nlogic jump mode\nbeq\n\n\n010\nj instr mode\njal\n\n\n011\njr mode\njr\n\n\njr、jalr 可以看成是 add 指令的延展，因为指令中的 rt 都是 $0 ,做加法后不影响结果，jalr 还可以直接合并数据通路写入 rd\nsplitter按照 R 、 I 、 J 三种方法区分出所有的信号即可\ngrf\n  \n    \n      Notice：\n\n    \n    \n      不修改 $0\n同步复位，上升沿修改，同时输出修改信息\n\n    \n  \n\nalu\n\n\naluOp\nfunction\n\n\n\n000000\nA + B(unsigned)\n\n\n000001\nA - B(unsigned)\n\n\n000010\nA or B\n\n\n000011\n{B[15:0],A[15:0]}\n\n\n000100\nA &#x3D;&#x3D; B ?\n\n\nmem和 grf 几乎一致，只需要注意没有 $0 的限制，输出格式略有不同即可\ncontroller\n  \n    \n      吐槽：\n\n    \n    \n      这才是真正的 core 吧\n\n    \n  \n\n首先从外部分析，需要对所有的mux发出choose信号，对alu发出op信号，对npc发出mode信号，对 grf 和 mem 发出写入信号（这样分类比较简单，并且完全将解析指令交给 controller 完成）\n然后就是根据指令集在数据流向路径上发出对应信号即可，不过要注意对每个部分保留缺省值，如写入信号默认为 0 ，mode 默认为 0（主要是有存储单元的部分），这样可以保证不会产生指令交叉\n\n  \n    \n      思考：\n\n    \n    \n      到流水线cpu中，存储单元暴增，或许可能会忘记设置缺省值，一定要小心\n\n    \n  \n\n这里列出所有的 choose 信号对应的含义：\n\n\n\nchoose\n000\n001\n010\n011\n100\n101\n110\n111\n\n\n\nrd1\nrs\n-\n-\n-\n-\n-\n-\n-\n\n\nrd2\nrt\n-\n-\n-\n-\n-\n-\n-\n\n\nwt\nrd\nrt\n5’d31\n-\n-\n-\n-\n-\n\n\nwdata\naluOut\nmemOut\n-\n-\n-\n-\n-\n-\n\n\nA\nGPR[rd1]\npc\n-\n-\n-\n-\n-\n-\n\n\nB\nGPR[rd2]\nimmZeroExt\nimmSignExt\n32’d4\n-\n-\n-\n-\n\n\nmemAdr\naluOut\n-\n-\n-\n-\n-\n-\n-\n\n\nmemWdata\nGPR[rd2]\n-\n-\n-\n-\n-\n-\n-\n\n\n通路设计按照总图把相应接口接起来即可。\n指令添加路径分为常规的 R、I、J型指令，以及一些奇奇怪怪的指令\n1.R-type需要修改的元件：controller、alu\n涉及的信号：rd1Choose、rd2Choose、wtChoose、wdataChoose、AChoose、BChoose\n存储信号： mode、grfWE、memWrite\n2.I-type3.J-type4.odd-type鸽鸽鸽……\n测试方案模块测试mux_testmodule mux32_test;    initial begin        // Initialize Inputs        choose = 0;        input0 = 1;        input1 = 2;        input2 = 3;        input3 = 4;        input4 = 5;        input5 = 6;        input6 = 7;        input7 = 8;    end    always #10 choose = choose + 1;      endmodule\n\npc_test initial begin  // Initialize Inputs  clk = 0;  reset = 1;  npc = 0;    #10 reset = 0; end  always #5 clk = ~clk;  always #10 npc = npc + 1;      endmodule\n\nnpc_testinitial begin // Initialize Inputs logicOutput = 0; mode = 0; pc = 32&#x27;h1f000004; immSignExt = 2; instr_index = 26; aluOut = 32; #30 logicOutput = 1;endalways #20 mode = mode + 1;\n\nsplitter_testinitial begin instr = 0; #20 instr = 32&#x27;h012a5020; //add  : 0x012a5020 #20 instr = 32&#x27;h016d5822; //sub  : 0x016d5822   #20 instr = 32&#x27;h356b7f3c; //ori  : 0x356b7f3c #20 instr = 32&#x27;h8d2c1234; //lw   : 0x8d2c1234 #20 instr = 32&#x27;had4c5678; //sw   : 0xad4c5678 #20 instr = 32&#x27;h11229abc; //beq  : 0x11229abc #20 instr = 32&#x27;h3c01def0; //lui  : 0x3c01def0 #20 instr = 32&#x27;h0c123456; //jal  : 0x0c123456 #20 instr = 32&#x27;h02a00008; //jr   : 0x02a00008 #20 instr = 32&#x27;h00000000; //nop  : 0x00000000end\n\ngrf_testinitial begin clk = 0; reset = 1; rd1 = 0; rd2 = 0; wt = 0; WE = 0; wdata = 32; #20 reset = 0;   rd1 = 1;   rd2 = 2;   wt = 0;   WE = 1; #20    rd1 = 0; //$0 can&#x27;t be modified   rd2 = 3; //$3 can   be modified   wt = 3;   WE = 1;  endalways #10 clk = ~clk;\n\nalu_testinitial begin // Initialize Inputs aluOp = 0; A = 32&#x27;h11ac5670; B = 32&#x27;ha1ac5670; #40 A = B;endalways #10 aluOp = aluOp + 1;\n\n对拍测试借鉴往届评测机，通过250份数据\n但是评测机没有发现 sw 有问题，经验证发现 sw 产生的问题是初始控制信号落空，产生的数据没有先 sw 的，但是课程组网站测试出来了\n思考题1.思考题1\n阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？\n\n\naddr 信号是 GPR[base] 和 offset 经过 ALU 计算后得来的；因为内部采用 [31:0] register 存储每一个字，为了保证地址能被 4 整除，所以选择 [11:2] 而不是 [9:0]\n2.思考题2\n至于表格的具体设计，则因人而异，可以记录下指令对应的控制信号如何取值，也可以记录下控制信号每种取值所对应的指令，在后面的 Project 中，这两种不同的译码方式将展现出各自的优劣，届时我们会再次对其进行详细分析。思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。\n\n第一种：\nalways @(*) begin    if (opcode == `special &amp;&amp; func == `add) begin        aluOp = `aluAdd;        muxA = `GPR[rs]        muxB = `GPR[rt]    endend\n\n第二种：\nassign aluOp = ((opcode == `special &amp;&amp; func == `add) || (opcode == `sw) || (opcode == `lw)) ? `aluAdd :               (opcode == `special &amp;&amp; func == `sub) ? `aluSub :               (opcode == `ori) ? `aluOr :               `default;\n\n\n\n\n方法\n代码量（资源占用）\n指令间耦合度\n可读性\n\n\n\n第一种\n多（因为某些信号需要在每条非定义指令中都被赋值为&#96;default）\n弱（相互独立）\n较好（可以对照指令表检查）\n\n\n第二种\n少\n强\n较差（需要对指令集有个整体观察）\n\n\n个人更喜欢第一种，因为不会让指令耦合过强导致相互影响，维护和添加新指令比较简单，但是缺点也很明显，为了防止模式残留，最好将所有信号都在每个分支赋值（就P4而言，只需在含存储单元的部分设置即可）\n3.思考题3\n在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。\n\n同步复位：clk &gt; reset（只有在 clk 上升沿，reset才发挥作用）\n异步复位：reset &gt; clk（指的是在复位时 clk 无法触发）\n4.思考题4\nC 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。\n\naddi 与 addiu 进行的计算都是 GPR[rs] + immediate\nadd 与 addu 进行的计算都是 GPR[rs] + GPR[rt]\n只不过，addi 和 add 在发生溢出的时候，\nIf the addition results in 32-bit 2’s complement arithmetic overflow, the destination register is not modified and an Integer Overflow exception occurs.\n只有当不溢出的情况下，才写入相应的寄存器，所以如果不考虑溢出，上述分支不会发生，则只会发生写入相应寄存器，则 addi 与 addiu 是等价的，add 与 addu 是等价的\n指令集\n\n\n\n\n\n\n\n\n","categories":["CO"],"tags":["Verilog","单周期CPU"]},{"title":"计组P7——流水线CPU（复杂指令集&支持异常处理）","url":"/2025/12/02/COP7/","content":"上级日记第一次没过强测，坐牢，所以建议第一次上机前要充分测试\n第二次加指令没过，交了，感觉题目不复杂，错一个点（提示信息是expected 正常 but 进入4180），但是不想再坐牢了\n描述是增加CP0[18]表示溢出判断使能，CP0[19]表示边界，add、addi、sub的结果如果绝对值大于这个边界(保证不大于0x7fff)，也算溢出\n有几个模糊的点都尝试了：应该是只针对 add、addi、sub ，并且无论你是暴力阻塞还是对 CP0 转发应该都可以\n关于绝对值的判断我是 abs = (out[31] == 1) ? ((~out) + 1) : out;\n提出来是因为我不是很确定，但是后来和同学聊了之后这是能过的，不是这的问题\n现在想来可能是一些很隐性的 bug ，没在强测里面体现出来，毕竟确实这题改的地方不多，我初版就是只改了 alu 和 cp0 ，然后把他俩连起来就完了，只错这一个点，后来又改成阻塞，还是没用，cp0 纯像个寄存器，alu 也陶腾了好几遍，感觉只能是别的问题了\n总而言之，完结快乐\n设计草稿\n\n\n任务\n解释\n\n\n\n计时器\n课程组提供实现代码，只需要结合代码和文档理解应用即可\n\n\n系统桥\n为 CPU 提供统一的访问外设的接口，需要按规格自行实现\n\n\n协处理器 CP0\n设置 CPU 的异常处理功能，反馈 CPU 的异常信息，需要按规格自行实现\n\n\n内部异常检测与流水\nCPU 需要具有可以检测内部指令执行错误的能力\n\n\n外部中断响应\nCPU 需要具有初步响应外部中断信号的能力\n\n\n异常处理指令\n在异常处理程序中，会有一些特殊的指令需要实现\n\n\n单周期 CPU 的封装\n让 CPU 从外部看上去是一个单周期 CPU\n\n\n异常处理程序\n利用 MARS 编写简单的异常处理程序用于测试\n\n\n\n建议：先整体把握所有要做的东西，然后按照外设-&gt;CP0-&gt;异常处理逻辑的顺序较好，主要是为了在写异常之前确认有哪些方向会出异常\n计时器tc不需要实现，但是需要了解功能与用法\n其端口设计相当于多加一个输出中断信号 IRQ 的 DM\n内部有 state 和三个寄存器 ctrl、preset、count\n\n\n\nreg\nI/O\nfunction\n\n\n\nctrl\nI/O\n[3]:中断使能，[2:1]:模式（mode0：倒数至 0 后持续中断，mode1：循环计数，mode2、3未定义），[0]：计数使能\n\n\npresent\nI/O\n初值\n\n\ncount\nO\n计数\n\n\n\n\n\n\nstate\nfunction\n\n\n\nIDLE\n初始状态，不计数\n\n\nLOAD\n每次开始计数前的准备，将present的数装入count\n\n\nCNT\n计数状态，ctrl[0] = 1 时有效\n\n\nINT\n结束状态，若ctrl[2:1] == 0，则产生持续中断信号（mode0），否则开始新一轮计数（mode1）\n\n\n系统桥bridge该模块需要完成两个功能：\n\n联系 CPU 和两个 tc 、以及其他外设\n根据访存地址分配相应的存储空间（简单来说就是分辨要读写外设的内存、中断寄存器还是 tc）\n\n由于理论上来说 grf 是属于 CPU 的，只是为了评测好像需要与外界相连，因此我们将grf相关信号直接从 CPU 连到 mips 端口，其他则需要按照设计走系统桥\n\n\n\ndef\nname\nfunction\n\n\n\ninput\ninterrupt\n外部中断信号\n\n\ninput\nIRQ0\ntc0中断信号\n\n\ninput\nIRQ1\ntc1中断信号\n\n\noutput[5:0]\nHWInt\n中断信号\n\n\n……\n……\n……\n\n\n定义格式： 为了区分顶层端口和 cpu，若是 CPU 的数据则在前面加 cpu_ 以作区分\n可以看到，bridge为组合逻辑，除了简单的交换数据流，会涉及到 HWInt、访存地址分配\n注意：\n\n请根据提交要求部分仔细查看相关要求\n虽然中断发生器在顶层模块没有读入数据口，但是仍然要实现读取功能（我们规定读出的数据始终保持 0）\nTimer0 输出的中断信号接入 HWInt[0] (最低中断位)，Timer1 输出的中断信号接入 HWInt[1]，来自中断发生器的中断信号接入 HWInt[2]\n\nCP0总要求\n\n\n\n端口名\n方向\n位宽\n描述\n\n\n\nclk\nIN\n1\n时钟信号\n\n\nreset\nIN\n1\n同步复位信号\n\n\nen\nIN\n1\n写使能信号\n\n\nCP0Add\nIN\n5\n寄存器地址\n\n\nCP0In\nIN\n32\nCP0 写入数据\n\n\nCP0Out\nOUT\n32\nCP0 读出数据\n\n\nVPC\nIN\n32\n受害 PC\n\n\nBDIn\nIN\n1\n是否是延迟槽指令\n\n\nExcCodeIn\nIN\n5\n记录异常类型\n\n\nHWInt\nIN\n6\n输入中断信号\n\n\nEXLClr\nIN\n1\n用来复位 EXL\n\n\nEPCOut\nOUT\n32\nEPC 的值\n\n\nReq\nOUT\n1\n进入处理程序请求\n\n\n需要实现 SR、Casuse、EPC 三个 CP0 寄存器，会通过 mfc0/mtc0 和异常处理与外界交互\n注意：\n\n请根据提交要求部分仔细查看相关要求\nCP0 寄存器的初始值均为 0，未实现位始终保持 0\n当进入中断或异常状态时，需将 EXL 置为 1；当退出中断或异常状态时，也需将 EXL 置为 0\nCause_IP将会每个周期被修改一次，修改的内容来自计时器和外部中断\n测试程序保证不会写入 Cause，但可能写入 SR 和 EPC\n\n1. SR（State Register）\n功能：配置异常\n编号：12\n\n\n\n格式\n15：10\n1\n0\n\n\n\n域名\nIM（Interrupt Mask）\nEXL（Exception Level）\nIE（Interrupt Enable）\n\n\n解释\n外部中断使能（按HWInt位）\n发生中断异常时置位并禁止中断异常\n全局中断使能\n\n\n2. Cause\n功能：记录异常发生的原因和情况\n编号：13\n\n\n\n格式\n31\n15：10\n6:2\n\n\n\n域名\nBD（Branch Delay）\nIP（Interrupt Pending）\nExcCode\n\n\n解释\n延迟槽标识\n中断来源\n异常编码\n\n\n3. EPC\n功能：记录异常处理结束后需要返回的 PC\n编号：14\n4. 外部信号处理\n可以发现 CP0Out 和 EPCOut 都是简单的读出数据端口，只需要分析 Req 的实现\nassign Req = (~`EXL &amp;&amp; ((`IE &amp;&amp; (`IM &amp; HWInt)) || (ExcCodeIn)))assign CP0Out = register[CP0Add];\tassign EPCOut = EPC;\n\n首先 EXL 需为 0 ，也即当前未处于中断异常处理状态，然后分中断和异常两种即可\n5. 内部寄存器逻辑\n按照以下优先级进行：\n（1）reset 复位（2）Req 中断异常请求（3）写入寄存器、EXLClr\n注意：IP是每个周期被修改一次，EXLClr 原理上不会和 Req 、load 同时发生\nalways @(posedge clk) begin\tif (reset) begin\t\tfor (i = 0 ; i &lt; 32 ; i = i + 1) begin\t\t\tregister[i] &lt;= 0;\t\tend\tend else begin\t\tif (Req) begin\t\t\t`EXL \t\t&lt;= 1;\t\t\t`BD \t\t&lt;= BDIn;\t\t\t`ExcCode\t&lt;= (`IE &amp;&amp; (`IM &amp; HWInt)) ? 0 : ExcCodeIn;\t\t\t`EPC \t\t&lt;= (BDIn) ? (VPC - 32'd4) : VPC;\t\tend else begin\t\t\tif (EXLClr) begin\t\t\t\t`EXL &lt;= 0;\t\t\tend\t\t\tif (en) begin\t\t\t\tregister[CP0Add] &lt;= load;\t\t\tend\t\tend\t\t`IP &lt;= HWInt;\tendend\n\n6. 添加mfc0、mtc0\n\n\n这里尤其需要注意格式\n异常响应机制异常码\n注意：\n\n分支跳转指令无论跳转与否，延迟槽指令为受害指令时 BD 均需要置位\n发生取指异常或 RI 异常后视为 nop 直至提交到 CP0\n跳转到不对齐的地址时，需要向 EPC 写入不对齐的地址\n对于未知指令的判断仅需考虑 opcode（和 R 型指令的 funct），且仅需判断是否出现在 P7 要求的指令集中，同时保证未知指令的测试用例中 opcode 和 funct 码的组合一定没有在 MARS 的基本指令集中出现。\n异常信号 ExcCode 应该流水到 CP0 所在的流水级，而不能直接提交到 CP0\n\n我们将 CP0 设置在 M 级\n注意：如果拖到 M 级判断地址是否非法，需要进行调整防止异常指令修改外设\n\n\n\n阶段\n可能发生的异常\n\n\n\nF\n取指异常(4)\n\n\nD\n系统调用(8),未知指令(10)\n\n\nE\n取数异常(4,计算地址时加法溢出)取数异常(4,地址非法)存数异常(5,计算地址时加法溢出)存数异常(5,地址非法)溢出异常(12)\n\n\n处理外部中断进入异常处理程序返回现场其他注意事项对于乘除槽的处理\n在进入中断或异常状态时，如果受害指令及其后续指令已经改变了 MDU 的状态，则无需恢复。假设 CP0 在 M 级，MDU 在 E 级，考虑以下情况：\n\nmult 在 E 级启动了乘法运算，流水到 M 级时产生了中断，此时无需停止乘法计算，其它乘除法指令同理。\nmthi 在 E 级修改了 HI 寄存器，流水到 M 级时产生了中断，此时无需恢复 HI 寄存器的值，mtlo 同理。\nmult 在 E 级，受害指令在 M 级，此时还未改变 MDU 状态，不应开始乘法计算，其它乘除法指令同理。\nmthi 在 E 级，受害指令在 M 级，此时还未改变 MDU 状态，不应修改 HI 寄存器的值，mtlo 同理。\n\n总的来说，由于我的设计是 CP0 放在 M 级，所以以乘除指令到达 M 级为准，如果是在此之前产生的，则不应该让乘除槽产生影响，否则无需回溯\n实现的方法就是向乘除槽传入 Req ，当 Req 为 1 时，不执行乘除指令，但是可以允许倒数\n这里我原来写的是如果 count == 0 &amp;&amp; Req == 0 就执行乘除指令，否则倒数，这会产生Your register outputs are too few.It's also possible that TLE happened.的错误\n分析：count为 0 ，Req 为 1 时， count 会因为 Req 变成负数（不为0），然后就一直阻塞相关乘除指令，产生 TLE\n测试方案利用 Mars 生成对拍程序，可以查看handler\n补充 nop 程序：\n#include&lt;bits/stdc++.h&gt;using namespace std;int main(){\tfreopen(\"nop.txt\",\"w\",stdout);\tint instrNum;\tcin&gt;&gt;instrNum;\t\t//已有指令数 \tfor(int i = 0 ; i &lt; 1120 - instrNum ; ++i) {printf(\"nop\\n\");}\treturn 0;} \n\n思考题1、思考题1\n请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？\n\n用户操作 、 硬件产生信号 、控制器发送中断 、CPU 暂停并在中断表中找到处理函数、操作系统驱动读取数据、转化为软件消息\n2、思考题2\n请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）\n\nCPU 处理中断必须使用指定好（由操作系统内核在启动时写入 IDT/IVT）的地址，中断是硬件对软件的强制调用。如果这个“强制调用”的目标地址可以由用户随意指定，那么恶意软件可以瞬间获得最高权限，任何程序都能窃听全局输入，恶意或错误的程序可以劫持调度机制，独占机器。\n3、思考题3\n为何与外设通信需要 Bridge？\n\n为了让昂贵且高速的 CPU 能够专注于计算，而将繁杂、低速、多样化的沟通工作外包出去，从而实现整个系统的高效协作\n4、思考题4\n请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。\n\nmode0:持续，mode1：循环\n\n5、思考题5\n倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？\n\n宏观 PC 检测到空泡的问题：如果气泡全空（PC=0），会导致中断返回地址（EPC）为 0，程序崩溃；如果丢失 BD 信息，会导致中断返回后无法重新跳转，程序逻辑错误。\n气泡必须携带的信息：PC 值（该时间片对应的指令地址），BD 状态（该时间片是否处于延迟槽中\n6、思考题6\n为什么 jalr 指令为什么不能写成 jalr 31？\n\n硬件规范禁止：MIPS 标准规定若 rs=rd，结果不可预测（可能导致跳转到下一条指令而不是目标地址）。数据冒险：容易愚弄流水线的前递逻辑。逻辑自杀：在保存旧的返回地址之前就将其覆盖，导致无法正确返回上一级函数\n附录异常码\n\n\n异常码\n助记符与名称\n指令\n描述\n\n\n\n0\nInt（外部中断）\n所有指令\n中断请求，来源于计时器与外部中断\n\n\n4\nAdEL（取指异常）\n所有指令\nPC 地址未字对齐PC 地址超过 0x3000 ~ 0x6ffc\n\n\n4\nAdEL（取数异常）\nlw\n取数地址未与 4 字节对齐\n\n\n\n\nlh\n取数地址未与 2 字节对齐\n\n\n\n\nlh, lb\n取 Timer 寄存器的值\n\n\n\n\nload 型指令\n计算地址时加法溢出\n\n\n\n\nload 型指令\n取数地址超出 DM、Timer0、Timer1、中断发生器的范围\n\n\n5\nAdES（存数异常）\nsw\n存数地址未 4 字节对齐\n\n\n\n\nsh\n存数地址未 2 字节对齐\n\n\n\n\nsh, sb\n存 Timer 寄存器的值\n\n\n\n\nstore 型指令\n计算地址加法溢出\n\n\n\n\nstore 型指令\n向计时器的 Count 寄存器存值\n\n\n\n\nstore 型指令\n存数地址超出 DM、Timer0、Timer1、中断发生器的范围\n\n\n8\nSyscall（系统调用）\nsyscall\n系统调用\n\n\n10\nRI（未知指令）\n-\n未知的指令码\n\n\n12\nOv（溢出异常）\nadd, addi, sub\n算术溢出\n\n\nhandler_entry:    # 保存上下文    beq $0,$0, _save_context    nop_main_handler:    # 取出 ExcCode    mfc0 $k0, $13    ori $k1, $0, 0x7c    and $k0, $k0, $k1    # 如果是中断，直接恢复上下文    beq $k0, $0, _restore_context    add $t0,$k0,$0        # 如果取指地址超出范围，则直接结束    mfc0 $k0, $14    ori $k1, $0, 0x3000    slt $k0, $k0, $k1    bne $k0, $0 , InstructionErrorEnd    add $t0,$k0,$0        mfc0 $k0, $14    ori $k1, $0, 0x6FFF    slt $k0, $k1, $k0    bne $k0, $0 , InstructionErrorEnd    add $t0,$k0,$0        # 如果取指地址不被 4 整除，则恢复    mfc0 $k0, $14    ori $k1, $0, 0x0003    and $k1, $k0, $k1    beq $k1, $0, skip_nowPC        andi $k0, $k0, 0xfffc    addi $k0, $k0, 4    mtc0 $k0, $14    beq $0,$0, _restore_context    add $t0,$k0,$0    # 将 EPC + 4，即处理异常的方法就是跳过当前指令    skip_nowPC:    mfc0 $k0, $14    addu $k0, $k0, 4    mtc0 $k0, $14    beq $0,$0, _restore_context    add $t0,$k0,$0_exception_return:    eret    add $k0,$k0,$0_save_context:    ori $k0, $0, 0x1000     # 在栈上找一块空间保存现场    addiu $k0, $k0, -256    sw $sp, 116($k0)        # 最先保存栈指针    move $sp, $k0    # 依次保存通用寄存器（注意要跳过 $sp）、HI 和 LO    sw $1, 4($sp)    sw $2, 8($sp)    sw $3, 12($sp)    sw $4, 16($sp)    sw $5, 20($sp)    sw $6, 24($sp)    sw $7, 28($sp)    sw $8, 32($sp)    sw $9, 36($sp)    sw $10, 40($sp)    sw $11, 44($sp)    sw $12, 48($sp)    sw $13, 52($sp)    sw $14, 56($sp)    sw $15, 60($sp)    sw $16, 64($sp)    sw $17, 68($sp)    sw $18, 72($sp)    sw $19, 76($sp)    sw $20, 80($sp)    sw $21, 84($sp)    sw $22, 88($sp)    sw $23, 92($sp)    sw $24, 96($sp)    sw $25, 100($sp)    sw $26, 104($sp)    sw $27, 108($sp)    sw $28, 112($sp)    # 跳过 $sp    sw $30, 120($sp)    sw $31, 124($sp)        sw $31, 124($sp)    mfhi $k0    mflo $k1    sw $k0, 128($sp)    sw $k1, 132($sp)    beq $0,$0, _main_handler    add $k0,$k0,$0_restore_context:    # 依次恢复通用寄存器（注意要跳过 $sp）、 HI 和 LO    lw $1, 4($sp)    lw $2, 8($sp)    lw $3, 12($sp)    lw $4, 16($sp)    lw $5, 20($sp)    lw $6, 24($sp)    lw $7, 28($sp)    lw $8, 32($sp)    lw $9, 36($sp)    lw $10, 40($sp)    lw $11, 44($sp)    lw $12, 48($sp)    lw $13, 52($sp)    lw $14, 56($sp)    lw $15, 60($sp)    lw $16, 64($sp)    lw $17, 68($sp)    lw $18, 72($sp)    lw $19, 76($sp)    lw $20, 80($sp)    lw $21, 84($sp)    lw $22, 88($sp)    lw $23, 92($sp)    lw $24, 96($sp)    lw $25, 100($sp)    lw $26, 104($sp)    lw $27, 108($sp)    lw $28, 112($sp)    # 跳过 $sp    lw $30, 120($sp)    lw $31, 124($sp)    lw $k0, 128($sp)    lw $k1, 132($sp)    mthi $k0    mtlo $k1    # 最后恢复栈指针    lw $sp, 116($sp)    beq $0,$0, _exception_return    add $k0,$k0,$0    InstructionErrorEnd:beq $0,$0,InstructionErrorEnd","categories":["CO"],"tags":["Verilog","五层流水线CPU"]},{"title":"计组P5——流水线CPU（简化指令集）","url":"/2025/11/10/COP5/","content":"上机日记一寄寄寄\n计算指令\n的前导一个数的前导零个数\n\n\n比较基础，不需要修改顶层，过。\ncjoc\n清空延迟槽指令\n\n\n寄在不会清空延迟槽，事实上只需要注意几点：\n\ncjoc暂停的时候不要清空FD，这个时候还没有产生跳转信号\n当准备就绪的时候，由npc发出清空信号，而不是由FD寄存器发出信号（会产生毛刺）\n\nload（不记得名字）\n\n\n\n分析一下，只可能是 0~16 号寄存器，在该指令到 E 时阻塞需要用到这些寄存器的指令，在 M 阻塞  为 0 且需要用到这些寄存器的指令，在 W 转发并写回\n上机日记二一小时速通三题，美美进入下一P\n忠告：千万不要指望能在课上干多少事，课下多翻翻往年博客，多归纳题型，无非就是计算、条件跳转（+链接、+清除延迟槽）、条件存储，用占位指令提前编好（这时就体现出用宏的重要性了，课上直接把opcode换了就行），尽量让课上需要修改的地方少一些，毕竟课下你还有同学、对拍机、ai辅助，课上犯蠢是真没招了\ndsc唯一一道卡我的\n描述：根据imm的高五位对 GPR[rt] 进行逻辑左移得到 result1，根据imm的低五位对 GPR[rt] 进行算术右移得到 result2，将result1 ^ result2 存入 GPR[rs] 中\n没有把 rs 和 rt 打反，这题上来让我咯噔一下就是这一点，但是事实上我的实现中每次用到 rs 和 rt 都是从 splitter 中解出来的，所以解法也很简单，特判然后交换就行了\n另一个知识点是要转成符号数，不然算术右移没用（具体哪一步不太清楚，只是觉得 wire 可能也会影响，所以单独开了 assign ，然后把所有的量都套了$signed然后过了）\nbloc无条件链接，根据前导一个数决定是否跳转\nlhp读出的memdata 与 GPR[rt] 异或后得到 temp\n如果 temp[31:16] == temp[15:0] ，则取其中的最高位1所在的位数作为存数寄存器地址，如果没有1就存到0\n如果 temp[31:16] != temp[15:0] ，则存到 31 号寄存器\n可能存到的寄存器在 16~31 ，其他的和往年题一样\n理论多周期CPU普林斯顿结构：指令和数据使用同一个内存\n\n将指令执行分解为多个步骤，每一步骤的执行，使用一个时钟周期\n在不同步骤执行中，可分时共享同一功能部件（如：Mem、ALU）\n每个步骤，增设寄存器，保存本步骤执行的结果，以供后续步骤使用\n\n流水线\n可实现多个任务同时工作，但占用不同的资源\n流水线改善了整体工作负载的吞吐率，但不改善单个任务处理延迟(latency)\n流水线速率受限于最慢的流水段\n潜在加速比 = 流水线级数\n流水段执行时间不平衡，则加速比下降\n填充流水线和排放流水线，加速比下降\n\n5 Stages of MIPS Datapath：\n\nIF: Instruction Fetch, Increment PC\nID: Instruction Decode, Read Registers\nEX: Execution (ALU) Load/Store: Calculate Address Others: Perform Operation\nMEM: Load: Read Data from Memory Store: Write Data to Memory\nWB: Write Data Back to Register\n\n流水线寄存器命名法则：前级/后级\n功能：时钟上升沿到来时，保存前级结果；之后输出至下级组合逻辑，也可能直接连接到下级流水线寄存器\n冒险hazard1.结构冒险同时占用某个部件产生的冒险\n如使用普林斯顿结构时取指令和访存冒险，同时占用grf的冒险\n解决方案：\n2.数据冒险后面的指令需要用到前面指令的结果产生的冒险\n增加旁路：\nadd $t1,$t2,$t3sub $t4,$t1,$t3and $t6,$t1,$t7or $s1,$s2,$t1xor $s3,$t1,$s4\n\n冻结：\nlw $t0,0($t1)sub $t3,$t0,$t2and $t5,$t0,$t4or $t7,$t0,$t6add $t1,$t2,$t3\n\n行为：\n\n冻结后续指令\n清空当前指令所在流水线寄存器\n冻结 PC\n\n如何修改：增加流水线寄存器和 PC 使能信号，添加指令时间判断\n取数指令延迟槽：即为插入的 nop\n\n  \n    \n      对编程的提示：\n\n    \n    \n      改善编译程序顺序（如在发生冒险的取数指令和计算指令之间放入一条后面需要算但是不产生冒险的指令），减少冒险，可以提高程序效率\n\n    \n  \n\n3.控制冒险例如分支指令需要使用计算结果决定是否跳转（这直接影响到下一条指令），但是计算结果需要经过 ALU 等获取（而这需要时间）\n\n  \n    \n      思路一：\n\n    \n    \n      先假设分支不发生，顺序执行，若后续需要跳转，清楚后续三条指令的所有相关流水线寄存器\n优点：如果不需要跳转，就没有指令损失\n缺点：清除逻辑比较复杂\n\n    \n  \n\n\n  \n    \n      思路二：\n\n    \n    \n      不使用 ALU ，而是在取数之后直接比较产生信号\n优点：被浪费的指令可能减少到 1 条\n缺点：如果依赖前序指令结果，则不能直接得到结果\n改进方案：增加旁路（已经有结果） + 冻结（还没有结果）\n\n    \n  \n\n分支延迟槽：可以发现两种思路都会运行后一条指令，所以可以插入 nop\n跳转延迟槽：发生跳转时后续有一条指令已经取出，只有原地跳转才会使用，所以应该在跳转指令后插入 nop\njal：下一条指令应该是 PC + 8\n设计草稿\n本次设计是将P4顶层连线拆开，即保留模块基本内容，重新排布组成\n无冒险五层流水CPU：\n\n冒险处理五层流水CPU：\n\n命名规范\n仅是个人习惯\n\n划分为 F（Fetch）、D（Decode）、E（Execute）、M（Memory）、W（Writeback）区\n流水线寄存器采用 X_Y_reg 命名，表示上游是 X 区，下游是 Y 区\n采用分布式译码，X 区特有的控制器命名为 X_ctrl\n实例化多选器时，命名为 dataChooser，表示选出 data 信号\n关于数据线的命名：\nX_data 表示的是在 X 区的 真实 数据，即已经经过冒险选择器的数据，而a_data 表示是从元件 a 发出的数据\n模块设计仅列出有改动的模块\n均采用 clk 上升沿有效，reset 同步复位\n1. pc\n\n\ndef\nname\n\n\n\ninput\nclk\n\n\ninput\nreset\n\n\ninput\nEn_low\n\n\ninput [31:0]\nnpc\n\n\noutput [31:0]\npc\n\n\nupdate: 低使能信号En_low\n2. npc\n\n\ndef\nname\n\n\n\ninput [2:0]\nmode\n\n\ninput [31:0]\npc\n\n\ninput [31:0]\nimmSignExt\n\n\ninput [25:0]\ninstr_index\n\n\ninput [31:0]\nD_rdata1\n\n\ninput [31:0]\nD_rdata2\n\n\noutput [31:0]\nnpc\n\n\nupdate: 将逻辑分支判断移到此处\n对于延迟槽，采用 pc@F + 4 的形式，等效于 pc@D + 8\n3. ALU\n\n\ndef\nname\n\n\n\ninput [5:0]\naluOp\n\n\ninput [31:0]\nA\n\n\ninput [31:0]\nB\n\n\noutput [31:0]\nout\n\n\nupdate: 不需要进行逻辑运算了\n4. grf &amp; memupdate: 增加 time_now ，满足输出格式需要\n5. reg为了实现代码复用，我只用流水寄存器存储 pc 和指令，以及必要的转发接口，经过分析可以得知，常见的需要存储数据的有 rdata1 ，rdata2，aluOut，logicOut，memOut\nX_Y_reg:\n其中 X_Y_data 表示由该流水寄存器存储的对应数据\n\n\n\ndef\nname\ndef\nname\ndef\nname\n\n\n\ninput [31:0]\nX_pc\ninput [31:0]\naluOut\noutput [31:0]\nX_Y_aluOut\n\n\ninput [31:0]\nX_instr\ninput [31:0]\nrdata1\noutput [31:0]\nX_Y_rdata1\n\n\noutput [31:0]\nY_pc\ninput [31:0]\nrdata2\noutput [31:0]\nX_Y_rdata2\n\n\noutput [31:0]\nY_instr\ninput [31:0]\nmemOut\noutput [31:0]\nX_Y_memOut\n\n\ninput\nreset\ninput\nclk\ninput\nEn\n\n\n6. controller实例化为 X_ctrl\n可以发现直接使用原来的controller就好了，而冒险控制器要考虑的就多了，实际使用时只连需要用的信号即可\n\n\n\ndef\nname\ndef\nname\n\n\n\ninput[5:0]\nopcode\noutput[2:0]\nrd1Choose\n\n\ninput[5:0]\nfunc\noutput[2:0]\nrd2Choose\n\n\noutput[2:0]\nwtChoose\noutput[2:0]\nwdataChoose\n\n\noutput[2:0]\nAChoose\noutput[2:0]\nBChoose\n\n\noutput[5:0]\naluOp\noutput[2:0]\nmode\n\n\noutput[2:0]\nmemAdrChoose\noutput[2:0]\nmemWdataChoose\n\n\noutput\ngrfWE\noutput[2:0]\nmemWrite\n\n\n\n\n\nchoose\n000\n001\n010\n011\n100\n101\n110\n111\n\n\n\nrd1\nrs\n-\n-\n-\n-\n-\n-\n-\n\n\nrd2\nrt\n-\n-\n-\n-\n-\n-\n-\n\n\nwt\nrd\nrt\n5’d31\n-\n-\n-\n-\n-\n\n\nwdata\naluOut\nmemOut\n-\n-\n-\n-\n-\n-\n\n\nA\nGPR[rd1]\npc\n-\n-\n-\n-\n-\n-\n\n\nB\nGPR[rd2]\nimmZeroExt\nimmSignExt\n32’d4\n-\n-\n-\n-\n\n\nmemAdr\naluOut\n-\n-\n-\n-\n-\n-\n-\n\n\nmemWdata\nGPR[rd2]\n-\n-\n-\n-\n-\n-\n-\n\n\n7. producer &amp; consumer显然可以看出可以将指令集分类如下：\n\ncal_r：add、sub\ncal_i：ori、lui\nsave：sw\nload：lw\nbranch:beq\njmode：j、jal\njrmode：jr、jalr\n\n\n\n\ntype\nT_use\ndata_requirement\nT_new(D/E)\ndata_offer\n\n\n\ncal_r\n1\nGPR[rs]、GPR[rt]\n1\nGPR[rd]\n\n\ncal_i\n1\nGPR[rs]\n1\nGPR[rt]\n\n\nload\n1\nGPR[rs]\n2\nGPR[rt]\n\n\nsave\n1、2\nGPR[rs] (1)、GPR[rt] (2)\n0\n-\n\n\nbranch\n0\nGPR[rs]、GPR[rt]\n0\n-\n\n\njmode\n0\n-\n1\n（）、ra(jal)\n\n\njrmode\n0\nGPR[rs]\n1\nGPR[rd]\n\n\n说明：将 jr 后面当作 pc + 4 的加法指令，存入 rd ($0)\nAT(address and time) 模型解释：\n冒险发生的条件：  （存在  满足，若已经执行完毕排出，不会发生冒险，且 $0 不会影响）\n使用暂停：\n使用转发：producer:\n\n\n\ndef\nname\n\n\n\ninput [31:0]\ninstr\n\n\ninput [2:0]\nTnow\n\n\noutput  [2:0]\nTnew\n\n\noutput  [4:0]\nA\n\n\n\n\n\nzone\nE\nM\nW\n\n\n\nTnow\n0\n1\n2\n\n\nconsumer:\n\n\n\ndef\nname\n\n\n\ninput [31:0]\ninstr\n\n\noutput  [4:0]\nA_1\n\n\noutput  [2:0]\nTuse_1\n\n\noutput  [4:0]\nA_2\n\n\noutput  [2:0]\nTuse_2\n\n\n8.hazard_ctrl应该算是本次实验最核心的部分，为了扩展性和封装性，我选择接收所有区域的指令到hazard_ctrl 内部计算  和  。\n\n\n\ndef\nname\ndef\nname\n\n\n\ninput[31:0]\nF_D_instr\noutput[2:0]\nD_rdata1Choose\n\n\ninput[31:0]\nD_E_instr\noutput[2:0]\nD_rdata2Choose\n\n\ninput[31:0]\nE_M_instr\noutput[2:0]\nE_rdata1Choose\n\n\ninput[31:0]\nM_W_instr\noutput[2:0]\nE_rdata2Choose\n\n\n\n\noutput[2:0]\nM_rdata2Choose\n\n\n\n\noutput\nstall\n\n\n\n\noutput\nclear\n\n\n选择信号（留的接口多就可以对齐）:\n\n\n\nchoose\n000\n001\n010\n011\n100\n101\n110\n111\n\n\n\nD_rdata1Choose\ngrf_rdata1\nM_aluOut\nW_memOut\nW_aluOut\n-\n-\n-\n-\n\n\nD_rdata2Choose\ngrf_rdata2\nM_aluOut\nW_memOut\nW_aluOut\n-\n-\n-\n-\n\n\nE_rdata1Choose\nD_E_rdata1\nM_aluOut\nW_memOut\nW_aluOut\n-\n-\n-\n-\n\n\nE_rdata2Choose\nD_E_rdata2\nM_aluOut\nW_memOut\nW_aluOut\n-\n-\n-\n-\n\n\nM_rdata2Choose\nE_M_rdata2\n-\nW_memOut\nW_aluOut\n-\n-\n-\n-\n\n\n选择逻辑：\n\n计算 F_D_instr 的 A（若不需要数据，则 A 值默认为 0） 和 \n计算后面三个寄存器中的 \n若产生冲突，根据最近的判断，如果 ，触发暂停，冻结PC、F_D_reg，排空 D_E_reg\n若  ，向前转发 A 值相同的\n\n测试方案经过 Mars 对拍测试，检验暂停转发功能。\n根据课程组给出的覆盖率模型，此处给出自己的手拍数据\n思考题\n1、我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。\n\n原因是因为提前了寄存器数据的使用，如果数据正在被写但又没有产生不可转发，就必须暂停，浪费了时间\nori $t1,$0,15beq $t1,$0,branch\n\n如果将 beq 放在 alu 中判断，就可以使用 M/W 寄存器转发的 ori 结果；如果提前分支判断，由于读出寄存器数据和ALU产生结果在同一周期，无法转发\n\n2、因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？\n\njal 指令后默认是延迟槽指令，而由于延迟槽的设计该指令已经被运行过，实际上 jal 希望链接顺序的下一条未被执行的指令，因此要写入 PC + 8\n\n3、我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM 、 ALU ），请思考为什么？\n\n在基本的设计中各区域已经基本平衡，从流水寄存器转发相当于开启一个新的阶段，不会增加区域关键路径；如果直接从功能部件转发，相当于把两个流水段连在一起，大大增加了该流水段的关键路径，为了照顾这个设计必须降低时钟频率，得不偿失\n\n4、我们为什么要使用 GPR 内部转发？该如何实现？\n\n因为在 D（解码）阶段和 W（写回）阶段都是对 GPR 进行操作，如果需要读的寄存器与要写的重合，此时在上升沿之前 GPR 里的数据还没更新，如果不进行内部转发就会导致读出来的数据是修改前的，与实际指令不符合\n在读出数据后加多选器，另一路连要写回的数据，由冒险控制器判断是否产生对应冒险并选出数据\n\n5、我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？\n\n就所给数据集而言，设计转发所需的数据都是已经产生但还未写入寄存器的数据\n因此供给者可以来自 E/M_reg(ALU) 、 M/W_reg(DM、ALU)\n需求者则是 nPC(GPR[rs]、GPR[rt]) 、 ALU(GPR[rs]、GPR[rt]) 、 DM(GPR[rt])\n\n6、在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。\n\n\n\n\ntype\nT_use\ndata_requirement\nT_new(D/E)\ndata_offer\n\n\n\ncal_r\n1\nGPR[rs]、GPR[rt]\n1\nGPR[rd]\n\n\ncal_i\n1\nGPR[rs]\n1\nGPR[rt]\n\n\nload\n1\nGPR[rs]\n2\nGPR[rt]\n\n\nsave\n1、2\nGPR[rs] (1)、GPR[rt] (2)\n0\n-\n\n\njump_register\n0\nGPR[rs]\n1\nGPR[ra] (GPR[rt])\n\n\nbranch\n0\nGPR[rs]、GPR[rt]\n0\n-\n\n\n\n7、确定你的译码方式，简要描述你的译码器架构，并思考该架构的优势以及不足。\n\n我采用分布式译码，每个流水段配置相应的controller和splitter，并流水指令instr，在每个流水段都进行译码产生控制信号。\n优势是能够保留足够多的信息，便于后面使用计算\n缺点是占用较多的存储资源，也会略微增加延迟\n\n1、[P5 选做] 在冒险的解决中，我们引入了 AT 法，如果你有其他的解决方案，请简述你的思路，并给出一段指令序列，简单说明你是如何做到尽力转发的。\n\n暂无\n\n2、[P5 选做] 请详细描述你的测试方案及测试数据构造策略。\n\n测试方案采用手造数据，主要测试冒险解决的情况，根据 AT 表进行组合，将可能会产生冒险的两条指令放在一起，并在前后加上赋值指令，检查中间经过了多少周期\n\n3、[P5、P6 选做] 请评估我们给出的覆盖率分析模型的合理性，如有更好的方案，可一并提出。\n\n暂无\n指令集\n\n\n\n\n\n\n\n\n","categories":["CO"],"tags":["Verilog","五层流水线CPU"]},{"title":"计组Pre","url":"/2025/09/26/COPre/","content":"Logisim初识Logisim\nLogisim，就是一个巨大的电路模拟器\n\n常用元件辨析\n善用元件\nTunnel（乾坤挪移）：让你的电路看起来不再一团乱麻\n\nProbe（见微知著）：测定每条线路的具体值，方便找到bug\n\nMUX（万剑归宗）：处理多种情况\n\nDUX(天女散花)：处理多种情况\n\nDecd(编不出来)：译码\n\n\n组合逻辑实操流程组合逻辑只与输入有关，并即刻变化，核心是写出逻辑表达式\nswap\n\n\nS\nA\nB\nO1\nO2\n\n\n\n0\n0\n0\n0\n0\n\n\n0\n0\n1\n0\n1\n\n\n0\n1\n0\n1\n0\n\n\n0\n1\n1\n1\n1\n\n\n1\n0\n0\n0\n0\n\n\n1\n0\n1\n1\n0\n\n\n1\n1\n0\n0\n1\n\n\n1\n1\n1\n1\n1\n\n\n\n\n\nVerilog值得注意1. 不要被顺序逻辑思维干扰begin    a &lt;= a + 1    ans &lt;= aend\n\n若运行前 a = 1 ，由于非阻塞赋值的关系，ans 应为 1\n2. 可综合规范\n一个寄存器只能在一个 always 块中赋值一次\n\n否则会出现不可综合的情况\n一次的理解：可以是在不同互斥的分支中进行不同的赋值\n\n在时序逻辑中，永远使用非阻塞赋值（&lt;=）；在组合逻辑中，永远使用阻塞赋值（=）\n\n用位运算来代替乘除法\n\n\n3. 编写状态机的时候，各个状态一定要命名之后调用的时候使用命名，而不是数字，减少代码中 magic number 的出现。建议使用 parameter，localparam 或者宏定义命名\n// GOODlocalparam sInit = 2'd0;// orparameter sInit = 2'd0;// or`define sInit 2'd0\n\n4. 注意状态转移例如匹配字符串，后面失配有可能是读到首位字符，要跳转到首位而不是0\n5. 注意相应时刻\n同步复位：在时钟上升沿到来时执行，与时钟周期同步。\n异步复位：只要reset信号达到上升沿就执行，与时钟周期不同步。\n\n上升沿读取、下降沿读取……\n6. 位拼接可以很好的处理独热编码e = {c1,c2,c3,c4}\n7. 多做测试，多做测试，多做测试不要妄想自己能一点点看出来，就算测试不能直接发现问题，对问题定位也是很有帮助的\nMIPS基础知识寄存器通用寄存器\n\n\nregister\nname\nusage\n\n\n\n$0\n$zero\n常量 0\n\n\n$1\n$at\n保留给汇编器使用的临时变量\n\n\n3\nv1\n函数调用返回值\n\n\n7\na3\n函数调用参数\n\n\n15\nt7\n临时变量\n\n\n23\ns7\n需要保存的变量\n\n\n25\nt9\n临时变量\n\n\n27\nk1\n留给操作系统使用\n\n\n$28\n$gp\n全局指针\n\n\n$29\n$sp\n堆栈指针\n\n\n$30\n$fp\n帧指针\n\n\n$31\n$ra\n返回地址\n\n\n一般不用对0的赋值无效\n特殊寄存器\nPC：它用于存储当前 CPU 正在执行的指令在内存中的地址。(值不能用常规的指令进行取值和赋值)\nHI：存放每次乘法结果的高 32 位，也被用来存放除法结果的余数。\nLO：存放每次乘法结果的低 32 位，也被用来存放除法结果的商。\n\nHI 和 LO 可以用 mfhi 和 mflo 提取\nCP0 寄存器此段照抄指导书，暂未提炼（P7 再说）\n当我们的 CPU 设计推进到比较深入的阶段时，我们就需要对异常和中断进行处理，届时我们就会使用到 CP0 寄存器。\nCP0 是一个系统控制协处理器，而 CP0 寄存器则是该协处理器工作时需要用到的一些寄存器。在我们的实验中，只会用到其中的 4 个寄存器：SR、Cause、EPC 和 PRId。\n这里先介绍一下这几个寄存器的职能，具体细节在 P7 时会详细讲解。\nSR：用于系统控制，决定是否允许异常和中断Cause：记录异常和中断的类型EPC：保存异常或中断发生时的 PC 值，也就是发送异常或中断时 CPU 正在执行的那条指令的地址。当处理完成之后，CPU 会根据这个地址返回到正常程序中继续往下执行。PRId：处理器 ID，用于实现个性的寄存器。\n语法指令格式：\n指令名 操作数 1, 操作数 2, 操作数 3\n存取指令格式：\n指令名 操作数 1, 操作数 3(操作数 2)\n一般来说，在 MIPS 指令集中，指令分为三种格式：R 型、I 型和 J 型。\n\nR 型指令：操作数最多，一般用于运算指令\nI 型指令：有 16 位的立即数或偏移\nJ 型指令：一般是跳转至某个地址\n\n为了方便（实际上是会将一些常用的指令进行简略助记），MIPS 还有一些扩展指令。想要了解更多的扩展指令，可以查看 Mars 的 Help 文档中 Extended (pseudo) Instructions 一栏。\n以下列出常用的\n\n\n\nname\nusage\nexample\nexplain\n\n\n\nli\n向寄存器存入立即数\nli $v0,10\n向 $v0 寄存器存入 10\n\n\nla\n向寄存器存入地址\nli $t0,label\n向 $t0 寄存器存入 label 所指的地址\n\n\nlw\n按字节从内存读取数据\nlw $t1,1($t0)\n以为首地址读取字数据到t1\n\n\nsw\n按字节向内存写入数据\nsw $t1,0($t0)\n以为首地址写字t1 的数据到内存\n\n\n标签.dataarray: .space 4 #数组首地址j namename:xxx\n\n标签用于表示一个地址，可以表示跳转地址、预处理数等等\n系统调用系统调用的模式大都相同，一般都是为 和v0 寄存器赋值，执行 syscall 指令，然后汇编器就会根据 $v0 寄存器中的值进行不同的操作\n\n\n\n服务\n服务号 ($v0)\n参数\n结果 / 返回值\n\n\n\n打印整数\n1\n$a0 = 要打印的整数\n-\n\n\n打印浮点数\n2\n$f12 = 要打印的浮点数\n-\n\n\n打印双精度数\n3\n$f12 = 要打印的双精度数\n-\n\n\n打印字符串\n4\n$a0 = 字符串的地址\n-\n\n\n读取整数\n5\n-\n$v0 = 读取到的整数\n\n\n读取浮点数\n6\n-\n$f0 = 读取到的浮点数\n\n\n读取双精度数\n7\n-\n$f0 = 读取到的双精度数\n\n\n读取字符串\n8\n$a0 = 字符串缓冲区的地址$a1 = 缓冲区长度\n-\n\n\n分配内存\n9\n$a0 = 需要分配的字节数\n$v0 = 分配内存的地址\n\n\n退出程序\n10\n-\n-\n\n\n打印字符\n11\n$a0 = 要打印的字符\n-\n\n\n读取字符\n12\n-\n$v0 = 读取到的字符\n\n\n退出程序（带状态码）\n17\n$a0 = 退出状态码\n-\n\n\n伪指令\n.data：用于预先存储数据的伪指令的开始标志。\n.text：程序代码指令开始的标志。\n.byte: 以字节为单位存储数据。\n.half: 以半字为单位存储数据。\n.word：以字为单位存储数据。\n.asciiz：以字节为单位存储字符串。\n.ascii: 以字节为单位存储字符串，但末尾不加 ‘\\0’\n.space：申请若干个字节的未初始化的内存空间。\nnop: 空操作。\n\n.dataarray:.space 40 #相当于 char[40]head:.asciiz \"hello world!\".textsw $0,array($0)li $v0,4la $a0,headsyscall\n\n宏.macro macro_name# 代码段.end_macro\n\n以上是宏定义的语法，实际上是替换成相应的代码段\n.macro end    li $v0,10    syscall.end_macroxxxend\n\n实际上就是：\nxxxli $v0,10syscall\n\n宏也可以设置一些参数灵活复用\n.macro  getindex(%ans, %i, %j)    sll %ans, %i, 3    add %ans, %ans, %j    sll %ans, %ans, 2.end_macro\n\n还有类似 C 语言的替换宏\n.eqv EQV_NAME string\n声明后会把 EQV_NAME 全部替换成 string\n循环与函数调用循环需要灵活利用逻辑判断跳转语句\n函数调用则更为复杂：\n调用：跳转语句 + 标签\n传参：参数数量较少时可以使用通用寄存器，参数数量较多或者需要递归调用要使用内存 + 栈指针的形式\n返回：递归调用时必须要明确返回地址和返回出口\n有两种方式保留参数和返回地址：\n\n由调用者保存\n由被调用者保存\n\n这里举由被调用者为例\n\n使用寄存器（或内存）存入相应的参数\n使用 jal 调用 function ，此时 $ra 中保存着下一条指令\n$sp 自减 4 （由于指向首地址，所以先减）， 然后使用 sw 存 $ra 中保存的返回地址\n$sp 自减并保存参数，如果有多个参数便依次存入\n执行函数\n用 $sp 自增依次退栈并把参数还原到相应的寄存器（或内存）中，最后读取返回地址到 $ra\njr $ra 返回到调用处\n\n注意\nsw 要保证地址能被 4 整除，所以保存参数一定要符合\n两种方式的区别仅在于谁管理数据\n\n实战心得省流省流：笔者在实战中犯的错误主要和内存相关，如没有注意可使用的内存区是哪些，$sp 回退混乱和错位（如sw 但没保证地址能被 4 整除），以及越界的问题\n建议对包含 sp 在内的指针初始化，避免指向不明区域\n\n\n\n内存区域\n地址范围\n大小\n用途\n访问权限\n编程指令\n\n\n\n保留区域\n0x00000000 - 0x00400000\n4MB\n系统保留（内核空间）\n❌ 不可访问\n-\n\n\n文本段\n0x00400000 - 0x10000000\n252MB\n程序代码存储\n👁️ 只读\n.text\n\n\n数据段\n0x10000000 - 0x10040000\n256KB\n全局变量、静态数据\n✏️ 可读可写\n.data（Compact, Data at Address 0模式从0开始）\n\n\n堆段\n0x10040000 - 0x7FFFFFFF\n~1.8GB\n动态内存分配\n✏️ 可读可写\nsbrk系统调用\n\n\n栈段\n0x7FFFEFFC - 0x80000000\n约1GB\n函数调用、局部变量\n✏️ 可读可写\n$sp寄存器管理\n\n\n提醒如果选择的是 Compact, Data at Address 0 模式，则程序从 0x00003000 开始存储， data 申请的数据空间只有 12288 Byte\n以下是一些题目分析\n哈密顿回路输入一个具有  个顶点的无向图  ，判断  是否有哈密尔顿回路。\n哈密顿回路的定义：设  是一个图，若  中一个回路通过且仅通过每一个顶点一次，则称这个回路为哈密顿回路。\n\n题目数据范围比较小，可以用 dfs 解决，指导书给出了相应的 c 语言代码，这里稍微分析一下\n#include &lt;stdio.h&gt;int G[8][8];    // 采用邻接矩阵存储图中的边int book[8];    // 用于记录每个点是否已经走过int m, n, ans;void dfs(int x) {    book[x] = 1;    int flag = 1, i;    // 判断是否经过了所有的点    for (i = 0; i &lt; n; i++) {        flag &amp;= book[i];    }    // 判断是否形成一条哈密顿回路    if (flag &amp;&amp; G[x][0]) {        ans = 1;        return;    }    // 搜索与之相邻且未经过的边    for (i = 0; i &lt; n; i++) {        if (!book[i] &amp;&amp; G[x][i]) {            dfs(i);        }    }    book[x] = 0;}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    int i, x, y;    for (i = 0; i &lt; m; i++) {        scanf(\"%d%d\", &amp;x, &amp;y);        G[x - 1][y - 1] = 1;        G[y - 1][x - 1] = 1;    }    // 从第0个点（编号为1）开始深搜    dfs(0);    printf(\"%d\", ans);    return 0;}\n\n核心部分在于 loop 输入和 dfs 的递归调用\n关于 loop 可以设置 loop 标签，在循环末尾计数器自增后判断如果符合循环条件则跳转到 loop ，否则顺延即结束循环\n还有一种写法再设置一个 continue 标签，可将跳转到 continue 作为 break\n关于 dfs 的实现这里笔者选择多传入一个计数器 sum ，这样可以少写一个循环来判断是否走完全程\n由于 G 和 book 都只看 01 ，这里笔者耍了小聪明选择 sb 和 lb 但是参数数量对不上导致 word 存储出错，我真是个大 sb\n解决方法也比较粗暴，单开一个 t7 作为  sum .\nPre上机\n我是猪\n\n心路历程Logisim 是个走地图，如果下一目标点违法（超出图外或是位于障碍处），那么就输出flag = 1 一个周期（初始默认为0），并且本次不移动，如果合法就移动，如果到目标点就输出 out = 0 ，然后采用的是异步复位信号\n猪波上来就确定 state 存 x 和 y 做 mealy 机，然后加两个判断机\n但是wa\n好在浏览了一遍后面两个很简单，skip skip skip\nVerilog 是输入 32 位，然后 4 位一划分对每个数据变换，然后再拼回去输出，是简单的组合逻辑，至于 %16 的要求，让他自然溢出即可\n这里给自己下了个小绊子，a0 忘记 assign 乐，好在看波形可以很轻松看出来\nMars 输入一个矩阵，根据输入参数输出其中的小矩阵，其实两次循环基本上结构差不多，写个 getaddress 的宏会很方便，记得 *4 对齐 word\n然后这里猪波又发癫了，输入 16 个数据发现还要输入，以为输入写错了，结果后面本来就要再输入 4 个参数\n最后 Logisim 很自然地找到了是 flag 输出地问题，九点之前疯狂改输出逻辑，但是无果，然后过时间了发现 pre 免费加长 60 分钟，然后冷静下来，盯着题目看见提示 reset后为0 想起来没给 flag 输出的寄存器接 reset\n总而言之，我是猪\n","categories":["CO"],"tags":["Logisim","MIPS","Verilog"]},{"title":"计组P6——流水线CPU（复杂指令集）","url":"/2025/11/20/COP6/","content":"课上回忆mujica非典型 I 型计算指令，主要修改点在于需要GPR【rt】参与计算\nimmExt &lt;- sign_ext(immediate16)temp &lt;- countOnes(immExt)if temp % 2 == 0 :    GPR[rt] &lt;- (GPR[rs] &amp; immExt) + GPR[rt]else :    GPR[rt] &lt;- (GPR[rs] | immExt) ^ GPR[rt]\n\nbotto感觉最有新意的题，主要修改点在于需要根据判断条件决定写入哪个寄存器\nhd &lt;- countOnes(GPR[rs] ^ GPR[rt])if  hd &lt; 8:    PC &lt;- PC + 4 + sign_ext(offset||2'b00)    GPR[rt] &lt;- hdelse if hd &lt;= 24:    PC &lt;- PC + 4    GPR[rs] &lt;- GPR[rt] &gt;&gt; hd    # 算术右移else:    PC &lt;- PC + 4    GPR[rs] &lt;- GPR[rs] ^ GPR[rt]   \n\n笔者的做法是流水一个reverse信号，注意只有在最后 WB 阶段才真正使用（在冒险控制器中只对计算供应者 A 值有效）\n更直白地说，在之后的操作里我将其包装成计算时无效，但是决定写入寄存器有效的 reverse 信号（把 rs 当 rt，rt 当 rs）\n还有一个坑点就是算术右移是 &gt;&gt;&gt; ，而且注意需要用 $signed()\nlwcm稍有变化但是并不复杂的一道题，需要在 M 阶段增加一个 WD 寄存器，这个寄存器只会被 lwcm 改变（初始为 0），并且影响着 lwcm 写入寄存器的地址\n读 memword 的操作不变if memword == WD :    GPR[rt] &lt;- memwordelse :    GPR[26] &lt;- memwordWD &lt;- memword   #先判断后赋值\n\n同 P5 ，如果是 rt 或 26 就考虑是否要阻塞；然后注意判断的时机是要把memword 写入 M/W 流水寄存器之前，笔者使用流水一个 flag 的方式供下一级使用\n设计草稿处理器应为五级流水线设计，支持如下指令集：\nadd, sub, and, or, slt, sltu, luiaddi, andi, orilb, lh, lw, sb, sh, swmult, multu, div, divu, mfhi, mflo, mthi, mtlobeq, bne, jal, jr\n\n要求存储器外置，即将 IM 和 DM 放置在 CPU 之外\n需有单独的乘除法模块和数据扩展模块\n除了乘除相关，其余指令均可直接添加\n乘除单元计算指令：mult, multu, div, divu\n存取指令：mfhi, mflo, mthi, mtlo\n计算指令和 mt 指令按 R 型指令理解都是 rd 为 0，因此只需要增加乘除计算即可，而针对 mf 指令我采取的思路是当作 ALUOut 处理\n由于是模拟延迟，所以照着要求写即可：\n\n执行乘法的时间为 5 个时钟周期，执行除法的时间为 10 个时钟周期（包含写入内部的 HI 和 LO 寄存器）\n自 Start 信号有效后的第 1 个 clock 上升沿开始，乘除法部件开始执行运算，同时将 Busy 置位为 1。\n在运算结果保存到 HI 寄存器和 LO 寄存器后，Busy 位清除为 0。\n当 Busy 信号或 Start 信号为 1 时，mult, multu, div, divu, mfhi, mflo, mthi, mtlo 等乘除法相关的指令均被阻塞在 D 流水级。\n数据写入 HI 寄存器或 LO 寄存器，均只需 1 个时钟周期。\n\n相当于一个状态机 + 2 个寄存器的组合，事实上可以组合逻辑算出来直接存入寄存器，然后暂停剩下的周期\n\n\n\ndef\nname\n\n\n\ninput\nclk\n\n\ninput\nreset\n\n\ninput [31:0]\nA\n\n\ninput [31:0]\nB\n\n\ninput [3:0]\nop\n\n\noutput\nbusy\n\n\noutput [31:0]\nout\n\n\n分析指令集，可知这八条指令的func满足01x0xx的格式，可以利用这个简化逻辑\n其中计算为0110xx，存取为0100xx\n测试方案思考题1. 思考题1\n为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？\n\n因为乘除法部件的执行乘法的时间为 5 个时钟周期，执行除法的时间为 10 个时钟周期，如果整合到 ALU 就会占用 ALU 很长时间，如果后续指令暂时不涉及乘除相关，也与结果无关，但这时也无法运行，导致效率低下\n独立的 HI、LO 寄存器我认为有两点好处，一是解决了目标寄存器如何确定，比如说乘法会产生高位和低位需要两个寄存器来存储，而非乘除的计算指令是计算完直接存到一个寄存器中；另一个是避免了冲突写入的问题，如果乘除完成时恰好也有一条别的计算指令在 ALU 完成，尝试写入同一寄存器时就会产生问题。总而言之，就是由于乘除的完成周期与其他指令有较大差异，为了方便处理最好需要有独立寄存器存储结果\n2. 思考题2\n真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。\n\n乘法：\n\n类比竖式计算， N 位乘法会产生 N 行部分积，然后相加，但现代 CPU 使用一种叫 Wallace Tree（华莱士树） 或 Compressor Tree（压缩器树） 的电路结构，这种由全加器组成的“树”可以并行地将几十个部分积迅速压缩成两个数（Sum 和 Carry）\n通过合理的方式将树合并的过程分割成几个流水段\n\n除法：\n现代高性能 CPU 大多使用 SRT 算法，它不强求算出精确的余数比较大小，而是只需要看余数的前几位，估算出一个商，如果估大了，下一位商可以是负数（-1），把多减的补回来\n3. 思考题3\n请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？\n\nmult、multu、div、divu 进入 D\\E 流水寄存器时，D\\E 会产生 start 信号（start = 1），然后乘除单元内部在下一个上升沿更新计数 count ，count 不为 0 时输出 busy 为 1，冒险控制单元检查只要 start | busy 为真，就将后续所有乘除相关指令阻塞在 D 级\n4. 思考题4\n请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）\n\n从清晰性来说，可以直观表示在一个字地址的哪些位置写入；从统一性来说，无论是字、半字还是字节，都能用相似的模式表示，对存储单元的描述更方便\n5. 思考题5\n请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？\n\n实际数据都是一个字，从DM获得的数据会进行扩展，写入的数据会将低位重复填充一个字，方便按字节使能写入\n如果数据未对齐，按字读写可能导致两次内存访问\n6. 思考题6\n为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？\n\n为指令分类，具有相似特性的指令归为一类，产生相似的控制信号\n能够快速地确定每条指令的控制信号如何产生\n7. 思考题7\n在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？\n\nmfhi、mflo 与其他需要读取寄存器的指令的冲突，将 mfhi、mflo 当作 R 型指令，设置相应的 Tnew\nori $t1,$0,2ori $t2,$0,3multmfhi $t3add $t4,$t3,$t3mflo $t5sub $t6,$t5,$t5\n\n8. 思考题8\n如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。\n\n手动构造策略为对指令种类两两组合，并间隔0~3条指令以覆盖所有情况\n","categories":["CO"],"tags":["Verilog","五层流水线CPU"]},{"title":"hello-world","url":"/2025/09/26/hello-world/","content":"","tags":["闲话"]},{"title":"语言模型","url":"/2025/12/27/languageModel/","content":"语言模型简单交互版\n","categories":["AI"],"tags":["语言模型"]},{"title":"机器学习","url":"/2025/11/29/machine-learning/","content":"引言机器学习的核心构成机器学习的核心组件：\n\n可以用来学习的数据（data）；\n如何转换数据的模型（model）；\n一个目标函数（objective function），用来量化模型的有效性；\n调整模型参数以优化目标函数的算法（algorithm）。\n\n数据： \n大多时候，它们遵循独立同分布(independently and identically distributed)。 \n样本有时也叫做数据点（data point）或者数据实例（data instance），通常每个样本由一组称为特征（features，或协变量（covariates））的属性组成。 \n机器学习模型会根据这些属性进行预测。 在上面的监督学习问题中，要预测的是一个特殊的属性，它被称为标签（label，或目标（target））。\n目标函数：\n当任务在试图预测数值时，最常见的损失函数是平方误差\n当试图解决分类问题时，最常见的目标函数是最小化错误率\n可用数据集通常可以分成两部分：训练数据集用于拟合模型参数，测试数据集用于评估拟合的模型。\n优化算法：\n深度学习中，大多流行的优化算法通常基于一种基本方法–梯度下降（gradient descent）。 简而言之，在每个步骤中，梯度下降法都会检查每个参数，看看如果仅对该参数进行少量变动，训练集损失会朝哪个方向移动。 然后，它在可以减少损失的方向上优化参数。\n机器学习经典问题监督学习监督学习（supervised learning）擅长在“给定输入特征”的情况下预测标签。 每个“特征-标签”对都称为一个样本（example）。 有时，即使标签是未知的，样本也可以指代输入特征。 我们的目标是生成一个模型，能够将任何输入特征映射到标签（即预测）。\n基本步骤：\n\n从已知大量数据样本中随机选取一个子集，为每个样本获取真实标签。有时，这些样本已有标签（例如，患者是否在下一年内康复？）；有时，这些样本可能需要被人工标记（例如，图像分类）。这些输入和相应的标签一起构成了训练数据集；\n选择有监督的学习算法，它将训练数据集作为输入，并输出一个“已完成学习的模型”；\n将之前没有见过的样本特征放到这个“已完成学习的模型”中，使用模型的输出作为相应标签的预测。\n\n例如：回归问题、分类问题、标记问题、搜索问题、推荐系统问题、序列学习问题（输入是连续的，模型可能就需要拥有“记忆”功能）\n无监督学习如果工作没有十分具体的目标，就需要“自发”地去学习\n\n聚类（clustering）问题：没有标签的情况下，我们是否能给数据分类呢？比如，给定一组照片，我们能把它们分成风景照片、狗、婴儿、猫和山峰的照片吗？同样，给定一组用户的网页浏览记录，我们能否将具有相似行为的用户聚类呢？\n\n主成分分析（principal component analysis）问题：我们能否找到少量的参数来准确地捕捉数据的线性相关属性？比如，一个球的运动轨迹可以用球的速度、直径和质量来描述。再比如，裁缝们已经开发出了一小部分参数，这些参数相当准确地描述了人体的形状，以适应衣服的需要。另一个例子：在欧几里得空间中是否存在一种（任意结构的）对象的表示，使其符号属性能够很好地匹配?这可以用来描述实体及其关系，例如“罗马” “意大利” “法国” “巴黎”。\n\n因果关系（causality）和概率图模型（probabilistic graphical models）问题：我们能否描述观察到的许多数据的根本原因？例如，如果我们有关于房价、污染、犯罪、地理位置、教育和工资的人口统计数据，我们能否简单地根据经验数据发现它们之间的关系？\n\n生成对抗性网络（generative adversarial networks）：为我们提供一种合成数据的方法，甚至像图像和音频这样复杂的非结构化数据。潜在的统计机制是检查真实和虚假数据是否相同的测试，它是无监督学习的另一个重要而令人兴奋的领域。\n\n\n强化学习强化学习（Reinforcement Learning, RL）是机器学习的一个重要分支，它涉及智能体（agent）在与环境交互的过程中，通过学习策略来实现目标，即获得最大化的回报或奖励。强化学习的核心在于智能体通过试错（trial and error）和延迟奖励（delayed reward）来学习最优策略。\n在强化学习问题中，智能体（agent）在一系列的时间步骤上与环境交互。 在每个特定时间点，智能体从环境接收一些观察（observation），并且必须选择一个动作（action），然后通过某种机制（有时称为执行器）将其传输回环境，最后智能体从环境中获得奖励（reward）。\n请注意，强化学习的目标是产生一个好的策略（policy）\n总结毋庸置疑，深度学习方法中最显著的共同点是使用端到端训练。 也就是说，与其基于单独调整的组件组装系统，不如构建系统，然后联合调整它们的性能。\n数据操作深度学习中主要使用张量（也就是 n 维数组）来存储处理数据\n","categories":["AI"],"tags":["机器学习"]},{"title":"面向对象先导OOPre","url":"/2025/11/04/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%88%E5%AF%BCOOPre/","content":"摘要本文梳理了面向对象先导课的主要脉络，基本按照课程顺序进行安排，但正文部分着重关注面向对象思想，暂时忽视代码细节，将JAVA语言部分放在文末。\n编程语言不是本课程的重点，本文也希望通过抽离核心思想以便能够在工程实践中灵活运用，不拘泥于某一编程语言。\n一、面向对象入门\n面向对象：以对象为中心来构建程序逻辑的方法\n对象：类的实例化结果，通过程序变量来访问\n类：数据（成员）与行为（方法）的综合逻辑体\n\n面向对象开发方法的三个复杂性控制机制：\n\n封装：让类的内部复杂性外部不可见\n继承：通过建立类之间的抽象层次来协同降低复杂性\n多态：类通过提供多种形态方法来解藕复杂性\n\n\n  \n    \n      理解：\n\n    \n    \n      封装体现在如成员私有化，只允许内部访问，从其他类的角度来说，不需要关心行为具体如何实现，只需要关注不同类之间的交互继承可以解决代码重用问题，使得代码层次化多态体现在重写方法，根据不同的场景能灵活实现相似功能\n\n    \n  \n\n二、类与对象、属性、方法\n类是一种自定义数据类型，包含数据以及操作数据的方法\n对象：类的实例化\n属性：定义类要管理的数据\n方法：定义类要提供的行为\n\n工具学习git基本配置从 git官网 下载，然后配置 git :\nbashgit config --global user.name &quot;你的名字&quot;git config --global user.email &quot;username@youxiangdizhi&quot;\n\n配置 SSH-key:\n\n生成查看本机公钥\n在github、gitlab 等添加 SSH-key\n\n基本操作bashgit clone 远程仓库地址           # 克隆远程仓库git add .                       # 向缓存区添加所有文件git commit -m &quot;这是注释&quot;         # 提交并写入提交信息git push                        # 提交到远程仓库git log                         # 查看提交历史git diff HEAD^ HEAD             # 比较当前提交与前一次提交的差异git diff master..feature-branch # 比较主分支与功能分支之间的差异git reset --hard HEAD^          # 回退到前一次提交git reset --hard &lt;commit-hash&gt;  # 回退到指定的提交git checkout &lt;commit-hash&gt;^ -- path/to/file # 恢复文件到特定提交的状态git checkout master             # 切换到主分支git branch feature-branch # 创建新分支git checkout feature-branch # 切换到新分支git branch -d feature-branch # 删除分支git merge feature-branch # 将 feature-branch 合并到当前分支\n\n详细教程ProGit\n编写代码工具笔者用的 vscode，大部分参考课程文档，下面从个人角度提供一份路径\n就课程而言，vscode 与 IDEA 最大的区别就是后者有十分详细的教程，以及高度图形化的提交流程，但是如果习惯使用git命令行指令的话，个人认为 vscode 更加轻量化，如果也想在 vscode 使用图形化，可以安装插件 GitLens — Supercharge Git in VS Code\n下面是推荐安装的插件\n\nCheckstyle for Java\nDebugger for Java\nExtension Pack for Java\nTest Runner for Java\n\nCheckstyle 使用指南：下载好课程组提供的 config.xml 并放到一个你喜欢的地方，打开 Checkstyle for Java 插件的“拓展设置”（可以通过点击插件右下角的齿轮图标找到），在“Checkstyle 配置文件所在路径”的输入框内输入你的 config.xml 所在的路径（如 D:\\config.xml）\n不过事实上，IDEA 的工程结构比较完善，能用还是尽量用吧\nJAVA 语言","categories":["OO"],"tags":["OO"]}]