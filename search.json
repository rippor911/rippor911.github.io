[{"title":"计组P0——Logisim 和 状态机","url":"/2025/09/30/COP0/","content":"课下grf\n子模块不能复用\n先做完子单元在复制\n记得改标签\n\nfsm最主要的问题是同步复位，为了控制是在上升沿接收，我选择用一个寄存器来存复位信息，但是这个复位该不该包含本身呢？\n如果包含了，就只会形成一个小刺虽说好像也可以吧，但是安全性要打个问号\n如果不包含呢，下一个上升沿就会涉及到输入到了但是复位还没归零的问题，总之就是不很美观\n所以最后采用了往年博客中的搭建方法，用多路选择器，如果复位信息被激活那就选择0，否则选择本身\nftoi不要排线太挤\n貌似评测的时候会对提交的 circuit 进行缩放之类的？然后就会让本来不该连在一起的线连起来了\n这个错误还是挺难分析出来的，如果上机遇到就寄了\n课上异步复位逻辑最方便的是利用寄存器自带的 0 搞事，我用的是做差方法，也就是输入 $a_0-7$ 然后输出 $a_0+7$\n后来助教告诉我可以用异或，因为两次异或同一个就没了，与 0 异或可以赋值\n第二种方法更快一点\nTunnel 问题大量复制之后要检查 Tunnel 的标签是不是对的\n","categories":["CO"],"tags":["Logisim"]},{"title":"计组P1——Verilog 和 状态机","url":"/2025/10/14/COP1/","content":"FSM 设计思路\n状态逻辑图\n状态化简\n状态编码\n状态转移（包含复位逻辑）\n输出逻辑\n\n课下省流\nop !&#x3D; Op\n多目运算符作为表达式，各部分符号会影响\n灵活运用位拼接符实现符号扩展：&#123;&#123;16&#123;imm[15:15]&#125;&#125;,imm[15:0]&#125;\nposedge clk or posedge clr (right)\n\n课上卷积急中生智用vscode替换代码，写了个超巨大，主要是不懂怎么在Verilog里面用循环，和第二题坐一桌\n音符记录维护支持四种操作的队列（大小为128，初始为全3’b000）：\n2’b00；添加一个数到末尾2’b01：查询特定位置的数2’b11：输出某个数出现次数2’b10：维持输出\nreg [2:0] queue [127:0];integer i;for(i = 0 ; i &lt; 128 ; i = i + 1) begin    ……end\n\njson匹配Moore机，注意输出的时间点在读到 “}” 后转移状态就已经改变输出了\n还有注意不要忘了空集的转移\n","categories":["CO"],"tags":["Verilog"]},{"title":"计组P2——学会当好的编译器","url":"/2025/10/21/COP2/","content":"MARS 编写 MIPS 汇编1.善用宏：\n.macro Name(%arg).end_macro\n\n使用参数的宏可以复用相似代码，让代码更简洁\n2.条件分支与循环控制：\n主要利用条件指令跳转，一定要注意转移方程（如i +&#x3D; 1），注意结束条件\ne = nextEdge[e]\n3.函数调用方法：\n使用 $sp 进行栈存储，需要注意后入先出，存储返回地址和可能会覆盖到的寄存器数据，保证返回时能够恢复到原来的样子\njal 指令可以链接到下一条指令（存储到 $ra）\nfunction:saveStack($ra)saveStack($t0)calculation……callSelf:jal functionreturn:readStack($t0)readStack($ra)jr $ra\n\n4.多维变量输入：\n都需要压成一维数组，建议用宏写 getAddress，保证地址计算方式一致的同时减少代码复制粘贴产生的冗余和错误\n5.格式化输入输出：\nF1 help 可以看 syscall 用法\nP2 题解01 迷宫核心思路：(这里我从 0 开始编号，和输入的起点终点编号有区别，注意区分)\nint fx[4] = &#123;-1,1,0,0&#125; , fy[4] = &#123;0,0,-1,1&#125;;void dfs(int x,int y) &#123;    mark[x][y] = 1;    if (x == goal_x &amp;&amp; y == goal_y) &#123;        sum++;        mark[x][y] = 0;        return;    &#125;    for(int i = 0 ; i &lt; 4 ; ++i) &#123;        int next_x = x + fx[i];        int next_y = y + fy[i];        if(next_x &lt; 0 || next_y &lt; 0 || next_x &gt;= n || next_y &gt;= m) continue;        if(mark[next_x][next_y] == 1 || map[next_x][next_y] == 1) continue; //mark是已经走过，map是输入时的map        dfs(nx,ny);    &#125;    mark[x][y] = 0;    return;&#125;\n\ndebug注意：\n\nx 和 next_x 占的寄存器搞得不太清楚（直接写的原因），有条件最好还是先用 c 写 core function\nsw 和 lw 混用\n\n课上反思数组的写入最好用寄存器记首地址，然后写一个统一的save和load宏，方便一一对应\ne = nextEdge[e]\n","categories":["CO"],"tags":["MIPS","Mars"]},{"title":"计组P3——单周期CPULogisim实现","url":"/2025/10/28/COP3/","content":"最终展示\n设计草稿指令分析(数据通路)\n\n\nInstruction\nPC_next\nReg1\nReg2\nWreg\nwdata\nALU_A\nALU_B\nDM_Adr\nDM_wdata\nEXT\n\n\n\nadd\nPC+4\nrs\nrt\nrd\nALU\nReg1\nReg2\n-\n-\n-\n\n\nsub\nPC+4\nrs\nrt\nrd\nALU\nReg1\nReg2\n-\n-\n-\n\n\nori\nPC+4\nrs\n-\nrt\nALU\nReg1\nEXT\n-\n-\nzero(imm16)\n\n\nlw\nPC+4\nrs\n-\nrt\nDM_out\nReg1\nEXT\nALU\n-\nsign(imm16)\n\n\nsw\nPC+4\nrs\nrt\n-\n-\nReg1\nEXT\nALU\nReg2\nsign(imm16)\n\n\nbeq\nPC+4(f) or PC+4+EXT(t)\nrs\nrt\n-\n-\nReg1\nReg2\n-\n-\nsign(imm16&lt;&lt;2)\n\n\nlui\nPC+4\n-\n-\nrt\nEXT_Hi\n-\n-\n-\n-\n不影响(imm16)\n\n\nnop\nPC+4\n-\n-\n-\n-\n-\n-\n-\n-\n-\n\n\njr\nReg1\nrs\nrt&#x3D;0\nrd&#x3D;0\n-(ALU)\nReg1\nReg2\n-\n-\n-\n\n\n\n  \n    \n      注意：\n\n    \n    \n      \nnop为空指令(0x00000000)，不进行任何有效行为（修改寄存器等）\nadd,sub 按无符号加减法处理（不考虑溢出）  （个人认为这里应该是说按照有符号的码位，但是按无符号处理）\n由于 jr 可以和 add 、 sub 兼容，即使对 $0 写入也不会发生改变，因此这里进行了合并\n\n\n    \n  \n\n模块制作1. IFU（取指令单元）\n\n\nname\nI&#x2F;O\nfunction\n\n\n\nreset\ninput\n异步复位\n\n\nclk\ninput\n时钟\n\n\nWE\ninput\n写入信号\n\n\nwdata[31:0]\ninput\n写入数据\n\n\nInstr[31:0]\noutput\n输出指令\n\n\npc[31:0]\noutput\n输出pc计数值\n\n\nPC 的起始位置为：0x00003000 ，但 ROM 的起始地址为 0x00000000 ，其实只影响 wdata 和 pc 两个位置，在内部可以仍然从 0 开始。\n注意：参考指令集，bge(t)时写入 PC + 4 + wdata\n根据数据通路可得到其内部结构：\n上表废弃，实践发现如果需要添加别的跳转指令，很难用单一的wdata表示，因此选用输入所有信号在IFU内部进行处理\n\n\n  \n    \n      勘误：\n\n    \n    \n      \nLogisim 的 ROM 地址是1、2、3，所以说应该 % 4 得到地址，但外部表现仍然是 + 4。\noffset就是偏移量，不需要减0x00003000\njr取出的地址是表地址，要化作内地址需要减偏移量\n\n\n    \n  \n\n2. GRF\n\n\nname\nI&#x2F;O\nfunction\n\n\n\nreset\ninput\n异步复位\n\n\nclk\ninput\n时钟\n\n\nReg1[4:0]\ninput\n读1\n\n\nReg2[4:0]\ninput\n读2\n\n\nWreg[4:0]\ninput\n写\n\n\nwdata[31:0]\ninput\n写入数据\n\n\nWE\ninput\n写入信号\n\n\noutput1[31:0]\noutput\n读出1\n\n\noutput2[31:0]\noutput\n读出2\n\n\n需要注意 $0 总保持 0，采用 4 * 8 排线，用译码器解出写入寄存器的行列，用标号tunnel输出\n每个单元如下：\n\n写入信号与Wreg的行列信号 and 后的到的指定寄存器\n\n  \n    \n      注意：\n\n    \n    \n      $0 总保持 0，复用时需要检查标号是否正确\n\n    \n  \n\n整体如下：\n\n3. ALU\n\n\nname\nI&#x2F;O\nfunction\n\n\n\nA[31:0]\ninput\n操作数A\n\n\nB[31:0]\ninput\n操作数B\n\n\nALUOp[2:0]\ninput\n运算信号\n\n\noutput[31:0]\noutput\n输出\n\n\nlogic\noutput\n逻辑输出\n\n\n本次初始指令集需要由 add、sub、or、equal种运算，为了可扩展性，选择编码ALUOp 为 3 位，即（更新：补充逻辑左移sll）\n\n\n\noperation\nALUOp\n\n\n\nadd\n000\n\n\nsub\n001\n\n\nor\n010\n\n\nequal\n011\n\n\nsll\n100\n\n\n结构如下：\n\n4. DM使用 RAM 即可，接入异步复位信号\n更新：提高可拓展性，分出信号选择区\n\n5. EXT使用 16-32EXT即可，注意后接逻辑左移，指向可能的跳转分支\n\n\n  \n    \n      勘误：\n\n    \n    \n      看清楚指令集中是signExt还是ZeroExt\n\n    \n  \n勘误：\n6.Controller根据数据通路表可以得到下图：\n\n第一次在这里犯了个错误，不是R指令才是写入rt。\n从中总结需要的控制信号有：not(Rinstr?)、RegWrite、ALUEXT?、RegChoose、ALUOp、MemWrite\n根据func可做Rdecoder(采用独热编码选择):\n\n根据信号连成下图：\n\n\n  \n    \n      Note：\n\n    \n    \n      可以看到Rdecoder和Controller都是六位译码，排线时可以复制左边，节约时间\nEXT勘误：注意符号扩展和零扩展，这里增加一个选扩展信号\n\n    \n  \n\n测试方案1.ori 和 sw先测试这两个的原因是main运行的时候没办法查看子电路内部，不过我的RAM是在main电路，通过这样的转换就可以查看grf的内部信息\n然后写了个 py 程序快速生成 32 个寄存器的查看（顺便检查一下有没有连错电路的）\nfor i in range(0,32):    print(f&quot;ori $&#123;i&#125;,$0,&#123;i&#125;&quot;)    print(f&quot;sw $&#123;i&#125;,($&#123;i&#125;)&quot;)\n\n嗯果不其然第四行确实是连错了，行线连的第三行的\n补充：\n其实是可以右键子电路查看的\n另外Logisim的RAM一个格子对应的是 4 word，所以上面这个程序写错了，而且sw要求偏移量能被 4 整除，所以整理如下：\nfor i in range(0,32):    print(f&quot;ori $&#123;i&#125;,$0,&#123;i&#125;&quot;)    print(f&quot;add $&#123;i&#125;,$&#123;i&#125;,$&#123;i&#125;&quot;)    print(f&quot;add $&#123;i&#125;,$&#123;i&#125;,$&#123;i&#125;&quot;)    print(f&quot;sw $&#123;i&#125;,($&#123;i&#125;)&quot;)\n\n2. 混合测试1使用以下教程提供的代码，使用它生成机器码，但是由于不考虑溢出，所以对拍数据用对应的addu查看\nori $a0, $0, 123ori $a1, $a0, 456lui $a2, 123            # 符号位为 0lui $a3, 0xffff         # 符号位为 1ori $a3, $a3, 0xffff    # $a3 = -1add $s0, $a0, $a2      # 正正add $s1, $a0, $a3      # 正负add $s2, $a3, $a3      # 负负ori $t0, $0, 0x0000sw $a0, 0($t0)sw $a1, 4($t0)sw $a2, 8($t0)sw $a3, 12($t0)sw $s0, 16($t0)sw $s1, 20($t0)sw $s2, 24($t0)lw $a0, 0($t0)lw $a1, 12($t0)sw $a0, 28($t0)sw $a1, 32($t0)ori $a0, $0, 1ori $a1, $0, 2ori $a2, $0, 1beq $a0, $a1, loop1     # 不相等beq $a0, $a2, loop2     # 相等loop1:sw $a0, 36($t0)loop2:sw $a1, 40($t0)\n\n检查出分支可能有问题，下面测试分支，检查后实现对IFU的勘误2\n3.混合测试2v2.0 raw341c0000341d000034013456002108208c010004ac0100043c027878004118223c0512343404000500000000ac85ffff8c83ffff106500011000000d3467040410e3000b000000003c0877773508ffff000800223400110000e650203408000034090001340a0001010a40201109fffe1000ffff\n\n转换成MIPS代码如下：\nori $28,$0,0ori $29,$0,0ori $1,$0,13398add $1,$1,$1 lw $1,4($0)sw $1,4($0)lui $2,30840sub $3,$2,$1lui $5,4660ori $4,$0,5nopsw $5,-1($4)lw $3,-1($4)beq $3,$5,nextbeq $0,$0,endnext:ori $7,$3,1028beq $7,$3,endnoplui $8,30583ori $8,$8,65535sub $0,$0,$8ori $0,4352add $10,$7,$6ori $8,$0,0ori $9,$0,1ori $10,$0,1uu:add $8,$8,$10last:beq $8,$9,uuend:beq $0,$0,end\n\n4.混合测试3ori $0,$0,72ori $1,$0,1ori $2,$0,2ori $3,$0,3ori $4,$0,4ori $5,$0,5ori $6,$0,6ori $7,$0,7ori $8,$0,8ori $9,$0,9ori $10,$0,10ori $11,$0,11ori $12,$0,12ori $13,$0,13ori $14,$0,14ori $15,$0,15ori $16,$0,16ori $17,$0,17ori $18,$0,18ori $19,$0,19ori $20,$0,20ori $21,$0,21ori $22,$0,22ori $23,$0,23ori $24,$0,24ori $25,$0,25ori $26,$0,26ori $27,$0,27ori $28,$0,28ori $29,$0,29ori $30,$0,30ori $31,$0,31lui $t1,0xffffori $t1,$t2,0xffffori $sp,$0,0loop:beq $t0,$31,nextsub $s1,$s2,$s3add $s3,$t0,$t6ori $t3,$t2,1000lui $5,0xabcdnopsw $t0,0($sp)add $sp,$sp,$4sw $t0,0($sp)lw $s2,-4($sp)nopadd $t0,$t0,$1beq $0,$0,loopnext:noplui $7,100\n\n为了检测输出，我模仿Pre和P0教程出现的测试电路，搭建出test：\n\n该测试方法需要与其他CPU对拍，这里我在双方均通过weak的情况下交换CPU测试，不建议一方未完成进行这种行为，只作学习参考使用。\n5.测评机对拍参考了COT进行测试，以下只是使用日记，参考价值不大。\n上来就报错：AttributeError: &#39;str&#39; object has no attribute &#39;keys&#39;\n先根据AI的提示，把：\n# 先设置基本属性self.__set_attr(file_config)if not self.__lazy:    file_config = self.__format_set(file_config)\n\n改成了\n# 先设置基本属性self.__set_attr(file_config)# 如果是非懒人模式，格式化设置并重新设置属性if not self.__lazy:    file_config = self.__format_set(file_config)    self.__set_attr(file_config)  # 重新设置格式化后的属性\n\n然后需要根据指南填写config，由于只是测简化指令，最好还是根据需求填config而不是用lazy mode。\n但是他给的 cpu 貌似在 logisim 运行的时候有问题，不知道是不是因为简化指令的锅，我在查看dif log的时候以为自己哪做错了，浪费了半天，才发现自己的cpu是叫mycpu而不是cpu（晕）\n其实不能过度依赖，毕竟和实际的评测环境还是有区别的，但是看到自己设计的cpu确实经过大规模数据测试Accepted还是有点小开心的\n扩展尝试鸽鸽鸽\n留好端口方便实现。\n思考题1. 第一题\n上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。\n\n上游（Moore机）：PC存储状态，输出取指令地址，经过跳转单元（若无跳转则为与 4 Add）得到下一次状态。\n下游（Mealy机）：可以理解为通用寄存器堆（GRF）作为状态存储单元，由指令（经过spiltter处理）作为输入信号（经过Controller生成控制信号形成最终的输入信号），控制着从GRF取值、控制ALU输出值，而写入信号与输出值共同控制状态转移\n2.第二题\n现在我们的模块中 IM 使用 ROM，DM 使用 RAM，GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。\n\n合理，IM在程序运行过程不会修改，所以选择ROM，而DM需要支持读出和写入，选择RAM，二者都需要多地址存储。而GRF是通用寄存器堆，用Register更方便，也更容易改装（如对$0始终保持0的改装）。\n3.第三题\n在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。\n\n我实现了Rdecoder，其功能是针对R型指令将func码转化成对应的ALUOp，具体细节参考上文Controller部分，补充下设计思路：使用和Controller类似的与门阵列，在连线时将输入调整成111111，可以降低连错的概率\n4.第四题\n事实上，实现 nop 空指令，我们并不需要将它加入控制信号真值表，为什么？\n\n因为nop不对任何存储单元操作（PC是自增，即使没有nop也会进行），因此nop没有相对应的控制信号\n5.第五题\n阅读 Pre 的“MIPS 指令集及汇编语言”一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。\n\n挺强的\n覆盖情况：缺少sub和nop，没有实现全覆盖\n测试强度：\n(1) I型指令：lui已经得到充分测试，但ori没有涉及检查0扩展和sign扩展（唯一一次用的是和0xffff0000，两种扩展结果相同），因此可以增加相应指令。lw 和 sw 有涉及，但是没有考虑 offset 为负数的情况，混合测试 2 中包含了这一点同样的，beq没有涉及 offset 为负数的情况，因此我考虑用 beq $0,$0,back 来检查是否能正常回溯。(2) R型指令：由于 add 和 sub 只考虑无符号，因此直接加减即可。\n附录指令集\n\n\n\n\n\n\n","categories":["CO"],"tags":["Logisim","单周期CPU"]},{"title":"COP4","url":"/2025/11/05/COP4/","content":"设计草稿总体设计图如下：\nerDiagram\n    mips {\n        input clk\n        input reset\n    }\n    mips ||--o{ pc : clk_rest\n    mips ||--o{ grf : clk_rest\n    mips ||--o{ mem : clk_rest\n\n\n    pc {\n        input clk\n        input reset\n        input[31_0] npc\n        output[31_0] adr\n    }\n\n    pc ||--o{ npc : adr\n    pc ||--o{ im : adr\n    pc ||--o{ muxGrfWdata : adr\n    pc ||--o{ grf : adr\n    pc ||--o{ mem : adr\n\n\n    npc {\n        input logicOutput\n        input[2_0]  mode\n        input[31_0] pc\n        input[31_0] immSignExt\n        input[25_0] instr_index\n        input[31_0] aluOut\n        output[31_0] npc\n    }\n\n    npc ||--o{ pc : npc\n    \n\n    im {\n        input[31_0] adr\n        output[31_0] instr\n    }\n\n    im ||--o{ spilter : instr\n\n    spilter {\n        input[31_0] instr\n        output[31_26] opcode\n        output[25_21] rs\n        output[20_16] rt\n        output[15_11] rd\n        output[10_6] shamt\n        output[5_0] func\n        output[15_0] imm\n        output[25_0] instr_index\n    }\n\n    spilter ||--o{ controller : opcode_func\n    spilter ||--o{ muxGrfRd1 : rs\n    spilter ||--o{ muxGrfRd2 : rt\n    spilter ||--o{ muxGrfWt : rd\n    spilter ||--o{ muxGrfWt : rt\n    spilter ||--o{ ext : imm\n    spilter ||--o{ npc : instr_index\n\n    controller {\n        input[5_0] opcode\n        input[5_0] func \n    }\n\n    controller ||--o{ muxGrfRd1 : rd1Choose\n    controller ||--o{ muxGrfRd2 : rd2Choose\n    controller ||--o{ muxGrfWt : wtChoose\n    controller ||--o{ muxGrfWdata : wdataChoose\n    controller ||--o{ muxA : AChoose\n    controller ||--o{ muxB : BChoose\n    controller ||--o{ muxMemAdr : memAdrChoose\n    controller ||--o{ muxMemWdata : memWdataChoose\n    controller ||--o{ alu : aluOp\n    controller ||--o{ grf : grfWE\n    controller ||--o{ mem : memWrite\n    controller ||--o{ npc : mode\n\n    muxGrfRd1 {\n        input[2_0] rd1Choose\n        input[5_0] rs\n        output[5_0] rd1\n    }\n\n    muxGrfRd1 ||--o{ grf : rd1\n\n    muxGrfRd2 {\n        input[2_0] rd2Choose\n        input[5_0] rt\n        output[5_0] rd2\n    }    \n\n    muxGrfRd2 ||--o{ grf : rd2\n\n    muxGrfWt {\n        input[2_0] wtChoose\n        input[5_0] rd\n        input[5_0] rt\n        output[5_0] wt\n    }    \n\n    muxGrfWt ||--o{ grf : wt\n\n    muxGrfWdata {\n        input[2_0] wdataChoose\n        input[31_0] aluOut\n        input[31_0] memOut\n        input[31_0] pc\n        output[31_0] wdata\n    }\n\n    muxGrfWdata ||--o{ grf : wdata\n\n    grf {\n        input clk\n        input reset\n        input[4_0] rd1\n        input[4_0] rd2\n        input[4_0] wt\n        input WE\n        input[31_0] wdata\n        input[31_0] wPc\n        output[31_0] rdata1\n        output[31_0] rdata2\n    }\n\n    grf ||--o{ muxA : rdata1\n    grf ||--o{ muxB : rdata2\n    grf ||--o{ muxMemWdata : rdata2\n\n\n    alu {\n        input[5_0] aluOp\n        input[31_0] A\n        input[31_0] B\n        output[31_0] output\n        output logicOutput\n    }\n\n    alu ||--o{ muxGrfWdata : aluOut\n    alu ||--o{ muxMemAdr : aluOut\n    alu ||--o{ npc : aluOut\n    alu ||--o{ npc : logicOutput\n\n    muxA {\n        input[2_0] Achoose\n        input[31_0] GPR[rs]\n        output[31_0] A\n    }\n\n    muxA ||--o{ alu : A\n\n    muxB {\n        input[2_0] Bchoose\n        input[31_0] GPR[rt]\n        input[31_0] immZeroExt\n        input[31_0] immSignExt\n        output[31_0] B\n    }\n\n    muxB ||--o{ alu : B    \n\n    muxMemAdr {\n        input[2_0] memAdrChoose\n        input[31_0] aluOut\n        output[31_0] memAdr\n    }\n\n    muxMemAdr ||--o{ mem : memAdr\n\n    muxMemWdata {\n        input[2_0] memWdataChoose\n        input[31_0] GPR[rt]\n        output[31_0] memWdata\n    }\n\n    muxMemWdata ||--o{ mem : memWdata\n\n    mem {\n        input clk\n        input reset\n        input[31_0] memAdr\n        input memWrite\n        input[31_0] wdata\n        input[31_0] wPc\n        output[31_0] memOut\n    }\n\n    mem ||--o{ muxGrfWdata : memOut\n\n    ext {\n        input[15_0] imm\n        output[31_0] immSignExt\n        output[31_0] immZeroExt\n    }\n\n    ext ||--o{ muxB : immZeroExt\n    ext ||--o{ muxB : immSignExt \n    ext ||--o{ npc : immSignExt\n\n总的来说，摒弃了P3中权责暧昧的设计，将所有控制信号完全交由controller进行控制，其他模块只管根据选择信号进行相应操作即可\n模块设计mux为了便于扩展，每个选择器都设置为三位选择信号，由controller统一发出\npc and im\n\n\ndef\nname\n\n\n\ninput\nclk\n\n\ninput\nreset\n\n\ninput[31:0]\nnpc\n\n\noutput[31:0]\npc\n\n\n@ posedge clk     if reset == 1:        pc &lt;= 32&#x27;h00003000    else:        pc &lt;= npc\n\nim需要注意：\nreg [31:0] im_reg [0:4095]; //4096个元素，每个元素是32位，注意数组大小是从小到大initial begin    $readmemh(&quot;code.txt&quot;, im_reg);endassign id = adr - 32&#x27;h00003000;assign instr = im_reg[id[31:2]];\n\nnpc\n\n\ndef\nname\n\n\n\ninput\nlogicOut\n\n\ninput[2:0]\nmode\n\n\ninput[31:0]\npc\n\n\ninput[31:0]\nimmSignExt\n\n\ninput[25:0]\ninstr_index\n\n\ninput[31:0]\naluOut\n\n\noutput[31:0]\nnpc\n\n\n\n\n\nmode\nfunction\nrelevant\n\n\n\n000\nnpc &#x3D; pc + 4\n-\n\n\n001\nlogic jump mode\nbeq\n\n\n010\nj instr mode\njal\n\n\n011\njr mode\njr\n\n\njr、jalr 可以看成是 add 指令的延展，因为指令中的 rt 都是 $0 ,做加法后不影响结果，jalr 还可以直接合并数据通路写入 rd\nsplitter按照 R 、 I 、 J 三种方法区分出所有的信号即可\ngrf\n  \n    \n      Notice：\n\n    \n    \n      不修改 $0\n同步复位，上升沿修改，同时输出修改信息\n\n    \n  \n\nalu\n\n\naluOp\nfunction\n\n\n\n000000\nA + B(unsigned)\n\n\n000001\nA - B(unsigned)\n\n\n000010\nA or B\n\n\n000011\n{B[15:0],A[15:0]}\n\n\n000100\nA &#x3D;&#x3D; B ?\n\n\nmem和 grf 几乎一致，只需要注意没有 $0 的限制，输出格式略有不同即可\ncontroller\n  \n    \n      吐槽：\n\n    \n    \n      这才是真正的 core 吧\n\n    \n  \n\n首先从外部分析，需要对所有的mux发出choose信号，对alu发出op信号，对npc发出mode信号，对 grf 和 mem 发出写入信号（这样分类比较简单，并且完全将解析指令交给 controller 完成）\n然后就是根据指令集在数据流向路径上发出对应信号即可，不过要注意对每个部分保留缺省值，如写入信号默认为 0 ，mode 默认为 0（主要是有存储单元的部分），这样可以保证不会产生指令交叉\n\n  \n    \n      思考：\n\n    \n    \n      到流水线cpu中，存储单元暴增，或许可能会忘记设置缺省值，一定要小心\n\n    \n  \n\n这里列出所有的 choose 信号对应的含义：\n\n\n\nchoose\n000\n001\n010\n011\n100\n101\n110\n111\n\n\n\nrd1\nrs\n-\n-\n-\n-\n-\n-\n-\n\n\nrd2\nrt\n-\n-\n-\n-\n-\n-\n-\n\n\nwt\nrd\nrt\n5’d31\n-\n-\n-\n-\n-\n\n\nwdata\naluOut\nmemOut\n-\n-\n-\n-\n-\n-\n\n\nA\nGPR[rd1]\npc\n-\n-\n-\n-\n-\n-\n\n\nB\nGPR[rd2]\nimmZeroExt\nimmSignExt\n32’d4\n-\n-\n-\n-\n\n\nmemAdr\naluOut\n-\n-\n-\n-\n-\n-\n-\n\n\nmemWdata\nGPR[rd2]\n-\n-\n-\n-\n-\n-\n-\n\n\n通路设计按照总图把相应接口接起来即可。\n指令添加路径分为常规的 R、I、J型指令，以及一些奇奇怪怪的指令\n1.R-type2.I-type3.J-type4.odd-type鸽鸽鸽……\n测试方案模块测试mux_testmodule mux32_test;    initial begin        // Initialize Inputs        choose = 0;        input0 = 1;        input1 = 2;        input2 = 3;        input3 = 4;        input4 = 5;        input5 = 6;        input6 = 7;        input7 = 8;    end    always #10 choose = choose + 1;      endmodule\n\npc_test initial begin  // Initialize Inputs  clk = 0;  reset = 1;  npc = 0;    #10 reset = 0; end  always #5 clk = ~clk;  always #10 npc = npc + 1;      endmodule\n\nnpc_testinitial begin // Initialize Inputs logicOutput = 0; mode = 0; pc = 32&#x27;h1f000004; immSignExt = 2; instr_index = 26; aluOut = 32; #30 logicOutput = 1;endalways #20 mode = mode + 1;\n\nsplitter_testinitial begin instr = 0; #20 instr = 32&#x27;h012a5020; //add  : 0x012a5020 #20 instr = 32&#x27;h016d5822; //sub  : 0x016d5822   #20 instr = 32&#x27;h356b7f3c; //ori  : 0x356b7f3c #20 instr = 32&#x27;h8d2c1234; //lw   : 0x8d2c1234 #20 instr = 32&#x27;had4c5678; //sw   : 0xad4c5678 #20 instr = 32&#x27;h11229abc; //beq  : 0x11229abc #20 instr = 32&#x27;h3c01def0; //lui  : 0x3c01def0 #20 instr = 32&#x27;h0c123456; //jal  : 0x0c123456 #20 instr = 32&#x27;h02a00008; //jr   : 0x02a00008 #20 instr = 32&#x27;h00000000; //nop  : 0x00000000end\n\ngrf_testinitial begin clk = 0; reset = 1; rd1 = 0; rd2 = 0; wt = 0; WE = 0; wdata = 32; #20 reset = 0;   rd1 = 1;   rd2 = 2;   wt = 0;   WE = 1; #20    rd1 = 0; //$0 can&#x27;t be modified   rd2 = 3; //$3 can   be modified   wt = 3;   WE = 1;  endalways #10 clk = ~clk;\n\nalu_testinitial begin // Initialize Inputs aluOp = 0; A = 32&#x27;h11ac5670; B = 32&#x27;ha1ac5670; #40 A = B;endalways #10 aluOp = aluOp + 1;\n\n对拍测试思考题1.思考题1\n阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？\n\n\naddr 信号是 GPR[base] 和 offset 经过 ALU 计算后得来的；因为内部采用 [31:0] register 存储每一个字，为了保证地址能被 4 整除，所以选择 [11:2] 而不是 [9:0]\n2.思考题2\n至于表格的具体设计，则因人而异，可以记录下指令对应的控制信号如何取值，也可以记录下控制信号每种取值所对应的指令，在后面的 Project 中，这两种不同的译码方式将展现出各自的优劣，届时我们会再次对其进行详细分析。思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。\n\n第一种：\nalways @(*) begin    if (opcode == `special &amp;&amp; func == `add) begin        aluOp = `aluAdd;        muxA = `GPR[rs]        muxB = `GPR[rt]    endend\n\n第二种：\nassign aluOp = ((opcode == `special &amp;&amp; func == `add) || (opcode == `sw) || (opcode == `lw)) ? `aluAdd :               (opcode == `special &amp;&amp; func == `sub) ? `aluSub :               (opcode == `ori) ? `aluOr :               `default;\n\n\n\n\n方法\n代码量（资源占用）\n指令间耦合度\n可读性\n\n\n\n第一种\n多（因为某些信号需要在每条非定义指令中都被赋值为&#96;default）\n弱（相互独立）\n较好（可以对照指令表检查）\n\n\n第二种\n少\n强\n较差（需要对指令集有个整体观察）\n\n\n个人更喜欢第一种，因为不会让指令耦合过强导致相互影响，维护和添加新指令比较简单，但是缺点也很明显，为了防止模式残留，最好将所有信号都在每个分支赋值（就P4而言，只需在含存储单元的部分设置即可）\n3.思考题3\n在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。\n\n同步复位：clk &gt; reset（只有在 clk 上升沿，reset才发挥作用）\n异步复位：reset &gt; clk（指的是在复位时 clk 无法触发）\n4.思考题4\nC 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。\n\naddi 与 addiu 进行的计算都是 GPR[rs] + immediate\nadd 与 addu 进行的计算都是 GPR[rs] + GPR[rt]\n只不过，addi 和 add 在发生溢出的时候，\nIf the addition results in 32-bit 2’s complement arithmetic overflow, the destination register is not modified and an Integer Overflow exception occurs.\n只有当不溢出的情况下，才写入相应的寄存器，所以如果不考虑溢出，上述分支不会发生，则只会发生写入相应寄存器，则 addi 与 addiu 是等价的，add 与 addu 是等价的\n指令集\n\n\n\n\n\n\n\n\n","tags":["Verilog","单周期CPU"]},{"title":"计组Pre","url":"/2025/09/26/COPre/","content":"Logisim初识Logisim\nLogisim，就是一个巨大的电路模拟器\n\n常用元件辨析\n善用元件\nTunnel（乾坤挪移）：让你的电路看起来不再一团乱麻\n\nProbe（见微知著）：测定每条线路的具体值，方便找到bug\n\nMUX（万剑归宗）：处理多种情况\n\nDUX(天女散花)：处理多种情况\n\nDecd(编不出来)：译码\n\n\n组合逻辑实操流程组合逻辑只与输入有关，并即刻变化，核心是写出逻辑表达式\nswap\n\n\nS\nA\nB\nO1\nO2\n\n\n\n0\n0\n0\n0\n0\n\n\n0\n0\n1\n0\n1\n\n\n0\n1\n0\n1\n0\n\n\n0\n1\n1\n1\n1\n\n\n1\n0\n0\n0\n0\n\n\n1\n0\n1\n1\n0\n\n\n1\n1\n0\n0\n1\n\n\n1\n1\n1\n1\n1\n\n\n$O1 &#x3D; \\tilde{S}A+SB$\n$O2 &#x3D; \\tilde{S}B+SA$\n\nVerilog值得注意1. 不要被顺序逻辑思维干扰begin    a &lt;= a + 1    ans &lt;= aend\n\n若运行前 a &#x3D; 1 ，由于非阻塞赋值的关系，ans 应为 1\n2. 可综合规范\n一个寄存器只能在一个 always 块中赋值一次\n\n否则会出现不可综合的情况\n一次的理解：可以是在不同互斥的分支中进行不同的赋值\n\n在时序逻辑中，永远使用非阻塞赋值（&lt;&#x3D;）；在组合逻辑中，永远使用阻塞赋值（&#x3D;）\n\n用位运算来代替乘除法$13*y &#x3D; (y&lt;&lt;3) + (y &lt;&lt; 2) + y$$a[2:0] &#x3D; a% 8$\n\n\n3. 编写状态机的时候，各个状态一定要命名之后调用的时候使用命名，而不是数字，减少代码中 magic number 的出现。建议使用 parameter，localparam 或者宏定义命名\n// GOODlocalparam sInit = 2&#x27;d0;// orparameter sInit = 2&#x27;d0;// or`define sInit 2&#x27;d0\n\n4. 注意状态转移例如匹配字符串，后面失配有可能是读到首位字符，要跳转到首位而不是0\n5. 注意相应时刻\n同步复位：在时钟上升沿到来时执行，与时钟周期同步。\n异步复位：只要reset信号达到上升沿就执行，与时钟周期不同步。\n\n上升沿读取、下降沿读取……\n6. 位拼接可以很好的处理独热编码e &#x3D; {c1,c2,c3,c4}\n7. 多做测试，多做测试，多做测试不要妄想自己能一点点看出来，就算测试不能直接发现问题，对问题定位也是很有帮助的\nMIPS基础知识寄存器通用寄存器\n\n\nregister\nname\nusage\n\n\n\n$0\n$zero\n常量 0\n\n\n$1\n$at\n保留给汇编器使用的临时变量\n\n\n$2-$3\n$v0-$v1\n函数调用返回值\n\n\n$4-$7\n$a0-$a3\n函数调用参数\n\n\n$8-$15\n$t0-$t7\n临时变量\n\n\n$16-$23\n$s0-$s7\n需要保存的变量\n\n\n$24-$25\n$t8-$t9\n临时变量\n\n\n$26-$27\n$k0-$k1\n留给操作系统使用\n\n\n$28\n$gp\n全局指针\n\n\n$29\n$sp\n堆栈指针\n\n\n$30\n$fp\n帧指针\n\n\n$31\n$ra\n返回地址\n\n\n一般不用$1,对$0的赋值无效\n特殊寄存器\nPC：它用于存储当前 CPU 正在执行的指令在内存中的地址。(值不能用常规的指令进行取值和赋值)\nHI：存放每次乘法结果的高 32 位，也被用来存放除法结果的余数。\nLO：存放每次乘法结果的低 32 位，也被用来存放除法结果的商。\n\nHI 和 LO 可以用 mfhi 和 mflo 提取\nCP0 寄存器此段照抄指导书，暂未提炼（P7 再说）\n当我们的 CPU 设计推进到比较深入的阶段时，我们就需要对异常和中断进行处理，届时我们就会使用到 CP0 寄存器。\nCP0 是一个系统控制协处理器，而 CP0 寄存器则是该协处理器工作时需要用到的一些寄存器。在我们的实验中，只会用到其中的 4 个寄存器：SR、Cause、EPC 和 PRId。\n这里先介绍一下这几个寄存器的职能，具体细节在 P7 时会详细讲解。\nSR：用于系统控制，决定是否允许异常和中断Cause：记录异常和中断的类型EPC：保存异常或中断发生时的 PC 值，也就是发送异常或中断时 CPU 正在执行的那条指令的地址。当处理完成之后，CPU 会根据这个地址返回到正常程序中继续往下执行。PRId：处理器 ID，用于实现个性的寄存器。\n语法指令格式：\n指令名 操作数 1, 操作数 2, 操作数 3\n存取指令格式：\n指令名 操作数 1, 操作数 3(操作数 2)\n一般来说，在 MIPS 指令集中，指令分为三种格式：R 型、I 型和 J 型。\n\nR 型指令：操作数最多，一般用于运算指令\nI 型指令：有 16 位的立即数或偏移\nJ 型指令：一般是跳转至某个地址\n\n为了方便（实际上是会将一些常用的指令进行简略助记），MIPS 还有一些扩展指令。想要了解更多的扩展指令，可以查看 Mars 的 Help 文档中 Extended (pseudo) Instructions 一栏。\n以下列出常用的\n\n\n\nname\nusage\nexample\nexplain\n\n\n\nli\n向寄存器存入立即数\nli $v0,10\n向 $v0 寄存器存入 10\n\n\nla\n向寄存器存入地址\nli $t0,label\n向 $t0 寄存器存入 label 所指的地址\n\n\nlw\n按字节从内存读取数据\nlw $t1,1($t0)\n以$t0 + 1 为首地址读取 1 字数据到 $t1\n\n\nsw\n按字节向内存写入数据\nsw $t1,0($t0)\n以$t0 为首地址写 1 字 $t1 的数据到内存\n\n\n标签.dataarray: .space 4 #数组首地址j namename:xxx\n\n标签用于表示一个地址，可以表示跳转地址、预处理数等等\n系统调用系统调用的模式大都相同，一般都是为 $a0 和 $v0 寄存器赋值，执行 syscall 指令，然后汇编器就会根据 $v0 寄存器中的值进行不同的操作\n\n\n\n服务\n服务号 ($v0)\n参数\n结果 &#x2F; 返回值\n\n\n\n打印整数\n1\n$a0 &#x3D; 要打印的整数\n-\n\n\n打印浮点数\n2\n$f12 &#x3D; 要打印的浮点数\n-\n\n\n打印双精度数\n3\n$f12 &#x3D; 要打印的双精度数\n-\n\n\n打印字符串\n4\n$a0 &#x3D; 字符串的地址\n-\n\n\n读取整数\n5\n-\n$v0 &#x3D; 读取到的整数\n\n\n读取浮点数\n6\n-\n$f0 &#x3D; 读取到的浮点数\n\n\n读取双精度数\n7\n-\n$f0 &#x3D; 读取到的双精度数\n\n\n读取字符串\n8\n$a0 &#x3D; 字符串缓冲区的地址$a1 &#x3D; 缓冲区长度\n-\n\n\n分配内存\n9\n$a0 &#x3D; 需要分配的字节数\n$v0 &#x3D; 分配内存的地址\n\n\n退出程序\n10\n-\n-\n\n\n打印字符\n11\n$a0 &#x3D; 要打印的字符\n-\n\n\n读取字符\n12\n-\n$v0 &#x3D; 读取到的字符\n\n\n退出程序（带状态码）\n17\n$a0 &#x3D; 退出状态码\n-\n\n\n伪指令\n.data：用于预先存储数据的伪指令的开始标志。\n.text：程序代码指令开始的标志。\n.byte: 以字节为单位存储数据。\n.half: 以半字为单位存储数据。\n.word：以字为单位存储数据。\n.asciiz：以字节为单位存储字符串。\n.ascii: 以字节为单位存储字符串，但末尾不加 ‘\\0’\n.space：申请若干个字节的未初始化的内存空间。\nnop: 空操作。\n\n.dataarray:.space 40 #相当于 char[40]head:.asciiz &quot;hello world!&quot;.textsw $0,array($0)li $v0,4la $a0,headsyscall\n\n宏.macro macro_name# 代码段.end_macro\n\n以上是宏定义的语法，实际上是替换成相应的代码段\n.macro end    li $v0,10    syscall.end_macroxxxend\n\n实际上就是：\nxxxli $v0,10syscall\n\n宏也可以设置一些参数灵活复用\n.macro  getindex(%ans, %i, %j)    sll %ans, %i, 3    add %ans, %ans, %j    sll %ans, %ans, 2.end_macro\n\n还有类似 C 语言的替换宏\n.eqv EQV_NAME string\n声明后会把 EQV_NAME 全部替换成 string\n循环与函数调用循环需要灵活利用逻辑判断跳转语句\n函数调用则更为复杂：\n调用：跳转语句 + 标签\n传参：参数数量较少时可以使用通用寄存器，参数数量较多或者需要递归调用要使用内存 + 栈指针的形式\n返回：递归调用时必须要明确返回地址和返回出口\n有两种方式保留参数和返回地址：\n\n由调用者保存\n由被调用者保存\n\n这里举由被调用者为例\n\n使用寄存器（或内存）存入相应的参数\n使用 jal 调用 function ，此时 $ra 中保存着下一条指令\n$sp 自减 4 （由于指向首地址，所以先减）， 然后使用 sw 存 $ra 中保存的返回地址\n$sp 自减并保存参数，如果有多个参数便依次存入\n执行函数\n用 $sp 自增依次退栈并把参数还原到相应的寄存器（或内存）中，最后读取返回地址到 $ra\njr $ra 返回到调用处\n\n注意\nsw 要保证地址能被 4 整除，所以保存参数一定要符合\n两种方式的区别仅在于谁管理数据\n\n实战心得省流省流：笔者在实战中犯的错误主要和内存相关，如没有注意可使用的内存区是哪些，$sp 回退混乱和错位（如sw 但没保证地址能被 4 整除），以及越界的问题\n建议对包含 sp 在内的指针初始化，避免指向不明区域\n\n\n\n内存区域\n地址范围\n大小\n用途\n访问权限\n编程指令\n\n\n\n保留区域\n0x00000000 - 0x00400000\n4MB\n系统保留（内核空间）\n❌ 不可访问\n-\n\n\n文本段\n0x00400000 - 0x10000000\n252MB\n程序代码存储\n👁️ 只读\n.text\n\n\n数据段\n0x10000000 - 0x10040000\n256KB\n全局变量、静态数据\n✏️ 可读可写\n.data（Compact, Data at Address 0模式从0开始）\n\n\n堆段\n0x10040000 - 0x7FFFFFFF\n~1.8GB\n动态内存分配\n✏️ 可读可写\nsbrk系统调用\n\n\n栈段\n0x7FFFEFFC - 0x80000000\n约1GB\n函数调用、局部变量\n✏️ 可读可写\n$sp寄存器管理\n\n\n提醒如果选择的是 Compact, Data at Address 0 模式，则程序从 0x00003000 开始存储， data 申请的数据空间只有 12288 Byte\n以下是一些题目分析\n哈密顿回路输入一个具有 $n$ 个顶点的无向图 $G$ ，判断 $G$ 是否有哈密尔顿回路。\n哈密顿回路的定义：设 $G&#x3D;(V,E)$ 是一个图，若 $G$ 中一个回路通过且仅通过每一个顶点一次，则称这个回路为哈密顿回路。\n$n &lt; 8 , m &lt; 100$\n题目数据范围比较小，可以用 dfs 解决，指导书给出了相应的 c 语言代码，这里稍微分析一下\n#include &lt;stdio.h&gt;int G[8][8];    // 采用邻接矩阵存储图中的边int book[8];    // 用于记录每个点是否已经走过int m, n, ans;void dfs(int x) &#123;    book[x] = 1;    int flag = 1, i;    // 判断是否经过了所有的点    for (i = 0; i &lt; n; i++) &#123;        flag &amp;= book[i];    &#125;    // 判断是否形成一条哈密顿回路    if (flag &amp;&amp; G[x][0]) &#123;        ans = 1;        return;    &#125;    // 搜索与之相邻且未经过的边    for (i = 0; i &lt; n; i++) &#123;        if (!book[i] &amp;&amp; G[x][i]) &#123;            dfs(i);        &#125;    &#125;    book[x] = 0;&#125;int main() &#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    int i, x, y;    for (i = 0; i &lt; m; i++) &#123;        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);        G[x - 1][y - 1] = 1;        G[y - 1][x - 1] = 1;    &#125;    // 从第0个点（编号为1）开始深搜    dfs(0);    printf(&quot;%d&quot;, ans);    return 0;&#125;\n\n核心部分在于 loop 输入和 dfs 的递归调用\n关于 loop 可以设置 loop 标签，在循环末尾计数器自增后判断如果符合循环条件则跳转到 loop ，否则顺延即结束循环\n还有一种写法再设置一个 continue 标签，可将跳转到 continue 作为 break\n关于 dfs 的实现这里笔者选择多传入一个计数器 sum ，这样可以少写一个循环来判断是否走完全程\n由于 G 和 book 都只看 01 ，这里笔者耍了小聪明选择 sb 和 lb 但是参数数量对不上导致 word 存储出错，我真是个大 sb\n解决方法也比较粗暴，单开一个 t7 作为  sum .\nPre上机\n我是猪\n\n心路历程Logisim 是个走地图，如果下一目标点违法（超出图外或是位于障碍处），那么就输出flag &#x3D; 1 一个周期（初始默认为0），并且本次不移动，如果合法就移动，如果到目标点就输出 out &#x3D; 0 ，然后采用的是异步复位信号\n猪波上来就确定 state 存 x 和 y 做 mealy 机，然后加两个判断机\n但是wa\n好在浏览了一遍后面两个很简单，skip skip skip\nVerilog 是输入 32 位，然后 4 位一划分对每个数据变换，然后再拼回去输出，是简单的组合逻辑，至于 %16 的要求，让他自然溢出即可\n这里给自己下了个小绊子，a0 忘记 assign 乐，好在看波形可以很轻松看出来\nMars 输入一个矩阵，根据输入参数输出其中的小矩阵，其实两次循环基本上结构差不多，写个 getaddress 的宏会很方便，记得 *4 对齐 word\n然后这里猪波又发癫了，输入 16 个数据发现还要输入，以为输入写错了，结果后面本来就要再输入 4 个参数\n最后 Logisim 很自然地找到了是 flag 输出地问题，九点之前疯狂改输出逻辑，但是无果，然后过时间了发现 pre 免费加长 60 分钟，然后冷静下来，盯着题目看见提示 reset后为0 想起来没给 flag 输出的寄存器接 reset\n总而言之，我是猪\n","categories":["CO"],"tags":["Logisim","Verilog","MIPS"]},{"title":"hello-world","url":"/2025/09/26/hello-world/","content":"","tags":["闲话"]},{"title":"面向对象先导OOPre","url":"/2025/11/04/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%88%E5%AF%BCOOPre/","content":"摘要本文梳理了面向对象先导课的主要脉络，基本按照课程顺序进行安排，但正文部分着重关注面向对象思想，暂时忽视代码细节，将JAVA语言部分放在文末。\n编程语言不是本课程的重点，本文也希望通过抽离核心思想以便能够在工程实践中灵活运用，不拘泥于某一编程语言。\n一、面向对象入门\n面向对象：以对象为中心来构建程序逻辑的方法\n对象：类的实例化结果，通过程序变量来访问\n类：数据（成员）与行为（方法）的综合逻辑体\n\n面向对象开发方法的三个复杂性控制机制：\n\n封装：让类的内部复杂性外部不可见\n继承：通过建立类之间的抽象层次来协同降低复杂性\n多态：类通过提供多种形态方法来解藕复杂性\n\n\n  \n    \n      理解：\n\n    \n    \n      封装体现在如成员私有化，只允许内部访问，从其他类的角度来说，不需要关心行为具体如何实现，只需要关注不同类之间的交互继承可以解决代码重用问题，使得代码层次化多态体现在重写方法，根据不同的场景能灵活实现相似功能\n\n    \n  \n\n二、类与对象、属性、方法\n类是一种自定义数据类型，包含数据以及操作数据的方法\n\n工具学习git基本配置从 git官网 下载，然后配置 git :\nbashgit config --global user.name &quot;你的名字&quot;git config --global user.email &quot;username@youxiangdizhi&quot;\n\n配置 SSH-key:\n\n生成查看本机公钥\n在github、gitlab 等添加 SSH-key\n\n基本操作bashgit clone 远程仓库地址           # 克隆远程仓库git add .                       # 向缓存区添加所有文件git commit -m &quot;这是注释&quot;         # 提交并写入提交信息git push                        # 提交到远程仓库git log                         # 查看提交历史git diff HEAD^ HEAD             # 比较当前提交与前一次提交的差异git diff master..feature-branch # 比较主分支与功能分支之间的差异git reset --hard HEAD^          # 回退到前一次提交git reset --hard &lt;commit-hash&gt;  # 回退到指定的提交git checkout &lt;commit-hash&gt;^ -- path/to/file # 恢复文件到特定提交的状态git checkout master             # 切换到主分支git branch feature-branch # 创建新分支git checkout feature-branch # 切换到新分支git branch -d feature-branch # 删除分支git merge feature-branch # 将 feature-branch 合并到当前分支\n\n详细教程ProGit\n编写代码工具笔者用的 vscode，大部分参考课程文档，下面从个人角度提供一份路径\n就课程而言，vscode 与 IDEA 最大的区别就是后者有十分详细的教程，以及高度图形化的提交流程，但是如果习惯使用git命令行指令的话，个人认为 vscode 更加轻量化，如果也想在 vscode 使用图形化，可以安装插件 GitLens — Supercharge Git in VS Code\n下面是推荐安装的插件\n\nCheckstyle for Java\nDebugger for Java\nExtension Pack for Java\nTest Runner for Java\n\nCheckstyle 使用指南：下载好课程组提供的 config.xml 并放到一个你喜欢的地方，打开 Checkstyle for Java 插件的“拓展设置”（可以通过点击插件右下角的齿轮图标找到），在“Checkstyle 配置文件所在路径”的输入框内输入你的 config.xml 所在的路径（如 D:\\config.xml）\n不过事实上，IDEA 的工程结构比较完善，能用还是尽量用吧\nJAVA 语言","tags":["OO"]}]