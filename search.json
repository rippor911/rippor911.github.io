[{"title":"计组P2——学会当好的编译器","url":"/2025/10/21/COP2/","content":"MARS 编写 MIPS 汇编1.善用宏：\n.macro Name(%arg).end_macro\n\n使用参数的宏可以复用相似代码，让代码更简洁\n2.条件分支与循环控制：\n主要利用条件指令跳转，一定要注意转移方程（如i +&#x3D; 1），注意结束条件\ne = nextEdge[e]\n3.函数调用方法：\n使用 $sp 进行栈存储，需要注意后入先出，存储返回地址和可能会覆盖到的寄存器数据，保证返回时能够恢复到原来的样子\njal 指令可以链接到下一条指令（存储到 $ra）\nfunction:saveStack($ra)saveStack($t0)calculation……callSelf:jal functionreturn:readStack($t0)readStack($ra)jr $ra\n\n4.多维变量输入：\n都需要压成一维数组，建议用宏写 getAddress，保证地址计算方式一致的同时减少代码复制粘贴产生的冗余和错误\n5.格式化输入输出：\nF1 help 可以看 syscall 用法\nP2 题解01 迷宫核心思路：(这里我从 0 开始编号，和输入的起点终点编号有区别，注意区分)\nint fx[4] = &#123;-1,1,0,0&#125; , fy[4] = &#123;0,0,-1,1&#125;;void dfs(int x,int y) &#123;    mark[x][y] = 1;    if (x == goal_x &amp;&amp; y == goal_y) &#123;        sum++;        mark[x][y] = 0;        return;    &#125;    for(int i = 0 ; i &lt; 4 ; ++i) &#123;        int next_x = x + fx[i];        int next_y = y + fy[i];        if(next_x &lt; 0 || next_y &lt; 0 || next_x &gt;= n || next_y &gt;= m) continue;        if(mark[next_x][next_y] == 1 || map[next_x][next_y] == 1) continue; //mark是已经走过，map是输入时的map        dfs(nx,ny);    &#125;    mark[x][y] = 0;    return;&#125;\n\ndebug注意：\n\nx 和 next_x 占的寄存器搞得不太清楚（直接写的原因），有条件最好还是先用 c 写 core function\nsw 和 lw 混用\n\n课上反思数组的写入最好用寄存器记首地址，然后写一个统一的save和load宏，方便一一对应\ne = nextEdge[e]\n","categories":["CO"],"tags":["MIPS","Mars"]},{"title":"计组P3——单周期CPULogisim实现","url":"/2025/10/28/COP3/","content":"最终展示\n设计草稿指令分析(数据通路)\n\n\nInstruction\nPC_next\nReg1\nReg2\nWreg\nwdata\nALU_A\nALU_B\nDM_Adr\nDM_wdata\nEXT\n\n\n\nadd\nPC+4\nrs\nrt\nrd\nALU\nReg1\nReg2\n-\n-\n-\n\n\nsub\nPC+4\nrs\nrt\nrd\nALU\nReg1\nReg2\n-\n-\n-\n\n\nori\nPC+4\nrs\n-\nrt\nALU\nReg1\nEXT\n-\n-\nzero(imm16)\n\n\nlw\nPC+4\nrs\n-\nrt\nDM_out\nReg1\nEXT\nALU\n-\nsign(imm16)\n\n\nsw\nPC+4\nrs\nrt\n-\n-\nReg1\nEXT\nALU\nReg2\nsign(imm16)\n\n\nbeq\nPC+4(f) or PC+4+EXT(t)\nrs\nrt\n-\n-\nReg1\nReg2\n-\n-\nsign(imm16&lt;&lt;2)\n\n\nlui\nPC+4\n-\n-\nrt\nEXT_Hi\n-\n-\n-\n-\n不影响(imm16)\n\n\nnop\nPC+4\n-\n-\n-\n-\n-\n-\n-\n-\n-\n\n\njr\nReg1\nrs\nrt&#x3D;0\nrd&#x3D;0\n-(ALU)\nReg1\nReg2\n-\n-\n-\n\n\n\n  \n    \n      注意：\n\n    \n    \n      \nnop为空指令(0x00000000)，不进行任何有效行为（修改寄存器等）\nadd,sub 按无符号加减法处理（不考虑溢出）  （个人认为这里应该是说按照有符号的码位，但是按无符号处理）\n由于 jr 可以和 add 、 sub 兼容，即使对 $0 写入也不会发生改变，因此这里进行了合并\n\n\n    \n  \n\n模块制作1. IFU（取指令单元）\n\n\nname\nI&#x2F;O\nfunction\n\n\n\nreset\ninput\n异步复位\n\n\nclk\ninput\n时钟\n\n\nWE\ninput\n写入信号\n\n\nwdata[31:0]\ninput\n写入数据\n\n\nInstr[31:0]\noutput\n输出指令\n\n\npc[31:0]\noutput\n输出pc计数值\n\n\nPC 的起始位置为：0x00003000 ，但 ROM 的起始地址为 0x00000000 ，其实只影响 wdata 和 pc 两个位置，在内部可以仍然从 0 开始。\n注意：参考指令集，bge(t)时写入 PC + 4 + wdata\n根据数据通路可得到其内部结构：\n上表废弃，实践发现如果需要添加别的跳转指令，很难用单一的wdata表示，因此选用输入所有信号在IFU内部进行处理\n\n\n  \n    \n      勘误：\n\n    \n    \n      \nLogisim 的 ROM 地址是1、2、3，所以说应该 % 4 得到地址，但外部表现仍然是 + 4。\noffset就是偏移量，不需要减0x00003000\njr取出的地址是表地址，要化作内地址需要减偏移量\n\n\n    \n  \n\n2. GRF\n\n\nname\nI&#x2F;O\nfunction\n\n\n\nreset\ninput\n异步复位\n\n\nclk\ninput\n时钟\n\n\nReg1[4:0]\ninput\n读1\n\n\nReg2[4:0]\ninput\n读2\n\n\nWreg[4:0]\ninput\n写\n\n\nwdata[31:0]\ninput\n写入数据\n\n\nWE\ninput\n写入信号\n\n\noutput1[31:0]\noutput\n读出1\n\n\noutput2[31:0]\noutput\n读出2\n\n\n需要注意 $0 总保持 0，采用 4 * 8 排线，用译码器解出写入寄存器的行列，用标号tunnel输出\n每个单元如下：\n\n写入信号与Wreg的行列信号 and 后的到的指定寄存器\n\n  \n    \n      注意：\n\n    \n    \n      $0 总保持 0，复用时需要检查标号是否正确\n\n    \n  \n\n整体如下：\n\n3. ALU\n\n\nname\nI&#x2F;O\nfunction\n\n\n\nA[31:0]\ninput\n操作数A\n\n\nB[31:0]\ninput\n操作数B\n\n\nALUOp[2:0]\ninput\n运算信号\n\n\noutput[31:0]\noutput\n输出\n\n\nlogic\noutput\n逻辑输出\n\n\n本次初始指令集需要由 add、sub、or、equal种运算，为了可扩展性，选择编码ALUOp 为 3 位，即（更新：补充逻辑左移sll）\n\n\n\noperation\nALUOp\n\n\n\nadd\n000\n\n\nsub\n001\n\n\nor\n010\n\n\nequal\n011\n\n\nsll\n100\n\n\n结构如下：\n\n4. DM使用 RAM 即可，接入异步复位信号\n更新：提高可拓展性，分出信号选择区\n\n5. EXT使用 16-32EXT即可，注意后接逻辑左移，指向可能的跳转分支\n\n\n  \n    \n      勘误：\n\n    \n    \n      看清楚指令集中是signExt还是ZeroExt\n\n    \n  \n勘误：\n6.Controller根据数据通路表可以得到下图：\n\n第一次在这里犯了个错误，不是R指令才是写入rt。\n从中总结需要的控制信号有：not(Rinstr?)、RegWrite、ALUEXT?、RegChoose、ALUOp、MemWrite\n根据func可做Rdecoder(采用独热编码选择):\n\n根据信号连成下图：\n\n\n  \n    \n      Note：\n\n    \n    \n      可以看到Rdecoder和Controller都是六位译码，排线时可以复制左边，节约时间\nEXT勘误：注意符号扩展和零扩展，这里增加一个选扩展信号\n\n    \n  \n\n测试方案1.ori 和 sw先测试这两个的原因是main运行的时候没办法查看子电路内部，不过我的RAM是在main电路，通过这样的转换就可以查看grf的内部信息\n然后写了个 py 程序快速生成 32 个寄存器的查看（顺便检查一下有没有连错电路的）\nfor i in range(0,32):    print(f&quot;ori $&#123;i&#125;,$0,&#123;i&#125;&quot;)    print(f&quot;sw $&#123;i&#125;,($&#123;i&#125;)&quot;)\n\n嗯果不其然第四行确实是连错了，行线连的第三行的\n补充：\n其实是可以右键子电路查看的\n另外Logisim的RAM一个格子对应的是 4 word，所以上面这个程序写错了，而且sw要求偏移量能被 4 整除，所以整理如下：\nfor i in range(0,32):    print(f&quot;ori $&#123;i&#125;,$0,&#123;i&#125;&quot;)    print(f&quot;add $&#123;i&#125;,$&#123;i&#125;,$&#123;i&#125;&quot;)    print(f&quot;add $&#123;i&#125;,$&#123;i&#125;,$&#123;i&#125;&quot;)    print(f&quot;sw $&#123;i&#125;,($&#123;i&#125;)&quot;)\n\n2. 混合测试1使用以下教程提供的代码，使用它生成机器码，但是由于不考虑溢出，所以对拍数据用对应的addu查看\nori $a0, $0, 123ori $a1, $a0, 456lui $a2, 123            # 符号位为 0lui $a3, 0xffff         # 符号位为 1ori $a3, $a3, 0xffff    # $a3 = -1add $s0, $a0, $a2      # 正正add $s1, $a0, $a3      # 正负add $s2, $a3, $a3      # 负负ori $t0, $0, 0x0000sw $a0, 0($t0)sw $a1, 4($t0)sw $a2, 8($t0)sw $a3, 12($t0)sw $s0, 16($t0)sw $s1, 20($t0)sw $s2, 24($t0)lw $a0, 0($t0)lw $a1, 12($t0)sw $a0, 28($t0)sw $a1, 32($t0)ori $a0, $0, 1ori $a1, $0, 2ori $a2, $0, 1beq $a0, $a1, loop1     # 不相等beq $a0, $a2, loop2     # 相等loop1:sw $a0, 36($t0)loop2:sw $a1, 40($t0)\n\n检查出分支可能有问题，下面测试分支，检查后实现对IFU的勘误2\n3.混合测试2v2.0 raw341c0000341d000034013456002108208c010004ac0100043c027878004118223c0512343404000500000000ac85ffff8c83ffff106500011000000d3467040410e3000b000000003c0877773508ffff000800223400110000e650203408000034090001340a0001010a40201109fffe1000ffff\n\n转换成MIPS代码如下：\nori $28,$0,0ori $29,$0,0ori $1,$0,13398add $1,$1,$1 lw $1,4($0)sw $1,4($0)lui $2,30840sub $3,$2,$1lui $5,4660ori $4,$0,5nopsw $5,-1($4)lw $3,-1($4)beq $3,$5,nextbeq $0,$0,endnext:ori $7,$3,1028beq $7,$3,endnoplui $8,30583ori $8,$8,65535sub $0,$0,$8ori $0,4352add $10,$7,$6ori $8,$0,0ori $9,$0,1ori $10,$0,1uu:add $8,$8,$10last:beq $8,$9,uuend:beq $0,$0,end\n\n4.混合测试3ori $0,$0,72ori $1,$0,1ori $2,$0,2ori $3,$0,3ori $4,$0,4ori $5,$0,5ori $6,$0,6ori $7,$0,7ori $8,$0,8ori $9,$0,9ori $10,$0,10ori $11,$0,11ori $12,$0,12ori $13,$0,13ori $14,$0,14ori $15,$0,15ori $16,$0,16ori $17,$0,17ori $18,$0,18ori $19,$0,19ori $20,$0,20ori $21,$0,21ori $22,$0,22ori $23,$0,23ori $24,$0,24ori $25,$0,25ori $26,$0,26ori $27,$0,27ori $28,$0,28ori $29,$0,29ori $30,$0,30ori $31,$0,31lui $t1,0xffffori $t1,$t2,0xffffori $sp,$0,0loop:beq $t0,$31,nextsub $s1,$s2,$s3add $s3,$t0,$t6ori $t3,$t2,1000lui $5,0xabcdnopsw $t0,0($sp)add $sp,$sp,$4sw $t0,0($sp)lw $s2,-4($sp)nopadd $t0,$t0,$1beq $0,$0,loopnext:noplui $7,100\n\n为了检测输出，我模仿Pre和P0教程出现的测试电路，搭建出test：\n\n该测试方法需要与其他CPU对拍，这里我在双方均通过weak的情况下交换CPU测试，不建议一方未完成进行这种行为，只作学习参考使用。\n5.测评机对拍参考了COT进行测试，以下只是使用日记，参考价值不大。\n上来就报错：AttributeError: &#39;str&#39; object has no attribute &#39;keys&#39;\n先根据AI的提示，把：\n# 先设置基本属性self.__set_attr(file_config)if not self.__lazy:    file_config = self.__format_set(file_config)\n\n改成了\n# 先设置基本属性self.__set_attr(file_config)# 如果是非懒人模式，格式化设置并重新设置属性if not self.__lazy:    file_config = self.__format_set(file_config)    self.__set_attr(file_config)  # 重新设置格式化后的属性\n\n然后需要根据指南填写config，由于只是测简化指令，最好还是根据需求填config而不是用lazy mode。\n但是他给的 cpu 貌似在 logisim 运行的时候有问题，不知道是不是因为简化指令的锅，我在查看dif log的时候以为自己哪做错了，浪费了半天，才发现自己的cpu是叫mycpu而不是cpu（晕）\n其实不能过度依赖，毕竟和实际的评测环境还是有区别的，但是看到自己设计的cpu确实经过大规模数据测试Accepted还是有点小开心的\n扩展尝试鸽鸽鸽\n留好端口方便实现。\n思考题1. 第一题\n上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。\n\n上游（Moore机）：PC存储状态，输出取指令地址，经过跳转单元（若无跳转则为与 4 Add）得到下一次状态。\n下游（Mealy机）：可以理解为通用寄存器堆（GRF）作为状态存储单元，由指令（经过spiltter处理）作为输入信号（经过Controller生成控制信号形成最终的输入信号），控制着从GRF取值、控制ALU输出值，而写入信号与输出值共同控制状态转移\n2.第二题\n现在我们的模块中 IM 使用 ROM，DM 使用 RAM，GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。\n\n合理，IM在程序运行过程不会修改，所以选择ROM，而DM需要支持读出和写入，选择RAM，二者都需要多地址存储。而GRF是通用寄存器堆，用Register更方便，也更容易改装（如对$0始终保持0的改装）。\n3.第三题\n在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。\n\n我实现了Rdecoder，其功能是针对R型指令将func码转化成对应的ALUOp，具体细节参考上文Controller部分，补充下设计思路：使用和Controller类似的与门阵列，在连线时将输入调整成111111，可以降低连错的概率\n4.第四题\n事实上，实现 nop 空指令，我们并不需要将它加入控制信号真值表，为什么？\n\n因为nop不对任何存储单元操作（PC是自增，即使没有nop也会进行），因此nop没有相对应的控制信号\n5.第五题\n阅读 Pre 的“MIPS 指令集及汇编语言”一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。\n\n挺强的\n覆盖情况：缺少sub和nop，没有实现全覆盖\n测试强度：\n(1) I型指令：lui已经得到充分测试，但ori没有涉及检查0扩展和sign扩展（唯一一次用的是和0xffff0000，两种扩展结果相同），因此可以增加相应指令。lw 和 sw 有涉及，但是没有考虑 offset 为负数的情况，混合测试 2 中包含了这一点同样的，beq没有涉及 offset 为负数的情况，因此我考虑用 beq $0,$0,back 来检查是否能正常回溯。(2) R型指令：由于 add 和 sub 只考虑无符号，因此直接加减即可。\n附录指令集\n\n\n\n\n\n\n","categories":["CO"],"tags":["Logisim","单周期CPU"]},{"title":"计组P0——Logisim 和 状态机","url":"/2025/09/30/COP0/","content":"课下grf\n子模块不能复用\n先做完子单元在复制\n记得改标签\n\nfsm最主要的问题是同步复位，为了控制是在上升沿接收，我选择用一个寄存器来存复位信息，但是这个复位该不该包含本身呢？\n如果包含了，就只会形成一个小刺虽说好像也可以吧，但是安全性要打个问号\n如果不包含呢，下一个上升沿就会涉及到输入到了但是复位还没归零的问题，总之就是不很美观\n所以最后采用了往年博客中的搭建方法，用多路选择器，如果复位信息被激活那就选择0，否则选择本身\nftoi不要排线太挤\n貌似评测的时候会对提交的 circuit 进行缩放之类的？然后就会让本来不该连在一起的线连起来了\n这个错误还是挺难分析出来的，如果上机遇到就寄了\n课上异步复位逻辑最方便的是利用寄存器自带的 0 搞事，我用的是做差方法，也就是输入 $a_0-7$ 然后输出 $a_0+7$\n后来助教告诉我可以用异或，因为两次异或同一个就没了，与 0 异或可以赋值\n第二种方法更快一点\nTunnel 问题大量复制之后要检查 Tunnel 的标签是不是对的\n","categories":["CO"],"tags":["Logisim"]},{"title":"计组P1——Verilog 和 状态机","url":"/2025/10/14/COP1/","content":"FSM 设计思路\n状态逻辑图\n状态化简\n状态编码\n状态转移（包含复位逻辑）\n输出逻辑\n\n课下省流\nop !&#x3D; Op\n多目运算符作为表达式，各部分符号会影响\n灵活运用位拼接符实现符号扩展：&#123;&#123;16&#123;imm[15:15]&#125;&#125;,imm[15:0]&#125;\nposedge clk or posedge clr (right)\n\n课上卷积急中生智用vscode替换代码，写了个超巨大，主要是不懂怎么在Verilog里面用循环，和第二题坐一桌\n音符记录维护支持四种操作的队列（大小为128，初始为全3’b000）：\n2’b00；添加一个数到末尾2’b01：查询特定位置的数2’b11：输出某个数出现次数2’b10：维持输出\nreg [2:0] queue [127:0];integer i;for(i = 0 ; i &lt; 128 ; i = i + 1) begin    ……end\n\njson匹配Moore机，注意输出的时间点在读到 “}” 后转移状态就已经改变输出了\n还有注意不要忘了空集的转移\n","categories":["CO"],"tags":["Verilog"]},{"title":"hello-world","url":"/2025/09/26/hello-world/","content":"","tags":["闲话"]},{"title":"计组Pre","url":"/2025/09/26/COPre/","content":"Logisim初识Logisim\nLogisim，就是一个巨大的电路模拟器\n\n常用元件辨析\n善用元件\nTunnel（乾坤挪移）：让你的电路看起来不再一团乱麻\n\nProbe（见微知著）：测定每条线路的具体值，方便找到bug\n\nMUX（万剑归宗）：处理多种情况\n\nDUX(天女散花)：处理多种情况\n\nDecd(编不出来)：译码\n\n\n组合逻辑实操流程组合逻辑只与输入有关，并即刻变化，核心是写出逻辑表达式\nswap\n\n\nS\nA\nB\nO1\nO2\n\n\n\n0\n0\n0\n0\n0\n\n\n0\n0\n1\n0\n1\n\n\n0\n1\n0\n1\n0\n\n\n0\n1\n1\n1\n1\n\n\n1\n0\n0\n0\n0\n\n\n1\n0\n1\n1\n0\n\n\n1\n1\n0\n0\n1\n\n\n1\n1\n1\n1\n1\n\n\n$O1 &#x3D; \\tilde{S}A+SB$\n$O2 &#x3D; \\tilde{S}B+SA$\n\nVerilog值得注意1. 不要被顺序逻辑思维干扰begin    a &lt;= a + 1    ans &lt;= aend\n\n若运行前 a &#x3D; 1 ，由于非阻塞赋值的关系，ans 应为 1\n2. 可综合规范\n一个寄存器只能在一个 always 块中赋值一次\n\n否则会出现不可综合的情况\n一次的理解：可以是在不同互斥的分支中进行不同的赋值\n\n在时序逻辑中，永远使用非阻塞赋值（&lt;&#x3D;）；在组合逻辑中，永远使用阻塞赋值（&#x3D;）\n\n用位运算来代替乘除法$13*y &#x3D; (y&lt;&lt;3) + (y &lt;&lt; 2) + y$$a[2:0] &#x3D; a% 8$\n\n\n3. 编写状态机的时候，各个状态一定要命名之后调用的时候使用命名，而不是数字，减少代码中 magic number 的出现。建议使用 parameter，localparam 或者宏定义命名\n// GOODlocalparam sInit = 2&#x27;d0;// orparameter sInit = 2&#x27;d0;// or`define sInit 2&#x27;d0\n\n4. 注意状态转移例如匹配字符串，后面失配有可能是读到首位字符，要跳转到首位而不是0\n5. 注意相应时刻\n同步复位：在时钟上升沿到来时执行，与时钟周期同步。\n异步复位：只要reset信号达到上升沿就执行，与时钟周期不同步。\n\n上升沿读取、下降沿读取……\n6. 位拼接可以很好的处理独热编码e &#x3D; {c1,c2,c3,c4}\n7. 多做测试，多做测试，多做测试不要妄想自己能一点点看出来，就算测试不能直接发现问题，对问题定位也是很有帮助的\nMIPS基础知识寄存器通用寄存器\n\n\nregister\nname\nusage\n\n\n\n$0\n$zero\n常量 0\n\n\n$1\n$at\n保留给汇编器使用的临时变量\n\n\n$2-$3\n$v0-$v1\n函数调用返回值\n\n\n$4-$7\n$a0-$a3\n函数调用参数\n\n\n$8-$15\n$t0-$t7\n临时变量\n\n\n$16-$23\n$s0-$s7\n需要保存的变量\n\n\n$24-$25\n$t8-$t9\n临时变量\n\n\n$26-$27\n$k0-$k1\n留给操作系统使用\n\n\n$28\n$gp\n全局指针\n\n\n$29\n$sp\n堆栈指针\n\n\n$30\n$fp\n帧指针\n\n\n$31\n$ra\n返回地址\n\n\n一般不用$1,对$0的赋值无效\n特殊寄存器\nPC：它用于存储当前 CPU 正在执行的指令在内存中的地址。(值不能用常规的指令进行取值和赋值)\nHI：存放每次乘法结果的高 32 位，也被用来存放除法结果的余数。\nLO：存放每次乘法结果的低 32 位，也被用来存放除法结果的商。\n\nHI 和 LO 可以用 mfhi 和 mflo 提取\nCP0 寄存器此段照抄指导书，暂未提炼（P7 再说）\n当我们的 CPU 设计推进到比较深入的阶段时，我们就需要对异常和中断进行处理，届时我们就会使用到 CP0 寄存器。\nCP0 是一个系统控制协处理器，而 CP0 寄存器则是该协处理器工作时需要用到的一些寄存器。在我们的实验中，只会用到其中的 4 个寄存器：SR、Cause、EPC 和 PRId。\n这里先介绍一下这几个寄存器的职能，具体细节在 P7 时会详细讲解。\nSR：用于系统控制，决定是否允许异常和中断Cause：记录异常和中断的类型EPC：保存异常或中断发生时的 PC 值，也就是发送异常或中断时 CPU 正在执行的那条指令的地址。当处理完成之后，CPU 会根据这个地址返回到正常程序中继续往下执行。PRId：处理器 ID，用于实现个性的寄存器。\n语法指令格式：\n指令名 操作数 1, 操作数 2, 操作数 3\n存取指令格式：\n指令名 操作数 1, 操作数 3(操作数 2)\n一般来说，在 MIPS 指令集中，指令分为三种格式：R 型、I 型和 J 型。\n\nR 型指令：操作数最多，一般用于运算指令\nI 型指令：有 16 位的立即数或偏移\nJ 型指令：一般是跳转至某个地址\n\n为了方便（实际上是会将一些常用的指令进行简略助记），MIPS 还有一些扩展指令。想要了解更多的扩展指令，可以查看 Mars 的 Help 文档中 Extended (pseudo) Instructions 一栏。\n以下列出常用的\n\n\n\nname\nusage\nexample\nexplain\n\n\n\nli\n向寄存器存入立即数\nli $v0,10\n向 $v0 寄存器存入 10\n\n\nla\n向寄存器存入地址\nli $t0,label\n向 $t0 寄存器存入 label 所指的地址\n\n\nlw\n按字节从内存读取数据\nlw $t1,1($t0)\n以$t0 + 1 为首地址读取 1 字数据到 $t1\n\n\nsw\n按字节向内存写入数据\nsw $t1,0($t0)\n以$t0 为首地址写 1 字 $t1 的数据到内存\n\n\n标签.dataarray: .space 4 #数组首地址j namename:xxx\n\n标签用于表示一个地址，可以表示跳转地址、预处理数等等\n系统调用系统调用的模式大都相同，一般都是为 $a0 和 $v0 寄存器赋值，执行 syscall 指令，然后汇编器就会根据 $v0 寄存器中的值进行不同的操作\n\n\n\n服务\n服务号 ($v0)\n参数\n结果 &#x2F; 返回值\n\n\n\n打印整数\n1\n$a0 &#x3D; 要打印的整数\n-\n\n\n打印浮点数\n2\n$f12 &#x3D; 要打印的浮点数\n-\n\n\n打印双精度数\n3\n$f12 &#x3D; 要打印的双精度数\n-\n\n\n打印字符串\n4\n$a0 &#x3D; 字符串的地址\n-\n\n\n读取整数\n5\n-\n$v0 &#x3D; 读取到的整数\n\n\n读取浮点数\n6\n-\n$f0 &#x3D; 读取到的浮点数\n\n\n读取双精度数\n7\n-\n$f0 &#x3D; 读取到的双精度数\n\n\n读取字符串\n8\n$a0 &#x3D; 字符串缓冲区的地址$a1 &#x3D; 缓冲区长度\n-\n\n\n分配内存\n9\n$a0 &#x3D; 需要分配的字节数\n$v0 &#x3D; 分配内存的地址\n\n\n退出程序\n10\n-\n-\n\n\n打印字符\n11\n$a0 &#x3D; 要打印的字符\n-\n\n\n读取字符\n12\n-\n$v0 &#x3D; 读取到的字符\n\n\n退出程序（带状态码）\n17\n$a0 &#x3D; 退出状态码\n-\n\n\n伪指令\n.data：用于预先存储数据的伪指令的开始标志。\n.text：程序代码指令开始的标志。\n.byte: 以字节为单位存储数据。\n.half: 以半字为单位存储数据。\n.word：以字为单位存储数据。\n.asciiz：以字节为单位存储字符串。\n.ascii: 以字节为单位存储字符串，但末尾不加 ‘\\0’\n.space：申请若干个字节的未初始化的内存空间。\nnop: 空操作。\n\n.dataarray:.space 40 #相当于 char[40]head:.asciiz &quot;hello world!&quot;.textsw $0,array($0)li $v0,4la $a0,headsyscall\n\n宏.macro macro_name# 代码段.end_macro\n\n以上是宏定义的语法，实际上是替换成相应的代码段\n.macro end    li $v0,10    syscall.end_macroxxxend\n\n实际上就是：\nxxxli $v0,10syscall\n\n宏也可以设置一些参数灵活复用\n.macro  getindex(%ans, %i, %j)    sll %ans, %i, 3    add %ans, %ans, %j    sll %ans, %ans, 2.end_macro\n\n还有类似 C 语言的替换宏\n.eqv EQV_NAME string\n声明后会把 EQV_NAME 全部替换成 string\n循环与函数调用循环需要灵活利用逻辑判断跳转语句\n函数调用则更为复杂：\n调用：跳转语句 + 标签\n传参：参数数量较少时可以使用通用寄存器，参数数量较多或者需要递归调用要使用内存 + 栈指针的形式\n返回：递归调用时必须要明确返回地址和返回出口\n有两种方式保留参数和返回地址：\n\n由调用者保存\n由被调用者保存\n\n这里举由被调用者为例\n\n使用寄存器（或内存）存入相应的参数\n使用 jal 调用 function ，此时 $ra 中保存着下一条指令\n$sp 自减 4 （由于指向首地址，所以先减）， 然后使用 sw 存 $ra 中保存的返回地址\n$sp 自减并保存参数，如果有多个参数便依次存入\n执行函数\n用 $sp 自增依次退栈并把参数还原到相应的寄存器（或内存）中，最后读取返回地址到 $ra\njr $ra 返回到调用处\n\n注意\nsw 要保证地址能被 4 整除，所以保存参数一定要符合\n两种方式的区别仅在于谁管理数据\n\n实战心得省流省流：笔者在实战中犯的错误主要和内存相关，如没有注意可使用的内存区是哪些，$sp 回退混乱和错位（如sw 但没保证地址能被 4 整除），以及越界的问题\n建议对包含 sp 在内的指针初始化，避免指向不明区域\n\n\n\n内存区域\n地址范围\n大小\n用途\n访问权限\n编程指令\n\n\n\n保留区域\n0x00000000 - 0x00400000\n4MB\n系统保留（内核空间）\n❌ 不可访问\n-\n\n\n文本段\n0x00400000 - 0x10000000\n252MB\n程序代码存储\n👁️ 只读\n.text\n\n\n数据段\n0x10000000 - 0x10040000\n256KB\n全局变量、静态数据\n✏️ 可读可写\n.data（Compact, Data at Address 0模式从0开始）\n\n\n堆段\n0x10040000 - 0x7FFFFFFF\n~1.8GB\n动态内存分配\n✏️ 可读可写\nsbrk系统调用\n\n\n栈段\n0x7FFFEFFC - 0x80000000\n约1GB\n函数调用、局部变量\n✏️ 可读可写\n$sp寄存器管理\n\n\n提醒如果选择的是 Compact, Data at Address 0 模式，则程序从 0x00003000 开始存储， data 申请的数据空间只有 12288 Byte\n以下是一些题目分析\n哈密顿回路输入一个具有 $n$ 个顶点的无向图 $G$ ，判断 $G$ 是否有哈密尔顿回路。\n哈密顿回路的定义：设 $G&#x3D;(V,E)$ 是一个图，若 $G$ 中一个回路通过且仅通过每一个顶点一次，则称这个回路为哈密顿回路。\n$n &lt; 8 , m &lt; 100$\n题目数据范围比较小，可以用 dfs 解决，指导书给出了相应的 c 语言代码，这里稍微分析一下\n#include &lt;stdio.h&gt;int G[8][8];    // 采用邻接矩阵存储图中的边int book[8];    // 用于记录每个点是否已经走过int m, n, ans;void dfs(int x) &#123;    book[x] = 1;    int flag = 1, i;    // 判断是否经过了所有的点    for (i = 0; i &lt; n; i++) &#123;        flag &amp;= book[i];    &#125;    // 判断是否形成一条哈密顿回路    if (flag &amp;&amp; G[x][0]) &#123;        ans = 1;        return;    &#125;    // 搜索与之相邻且未经过的边    for (i = 0; i &lt; n; i++) &#123;        if (!book[i] &amp;&amp; G[x][i]) &#123;            dfs(i);        &#125;    &#125;    book[x] = 0;&#125;int main() &#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    int i, x, y;    for (i = 0; i &lt; m; i++) &#123;        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);        G[x - 1][y - 1] = 1;        G[y - 1][x - 1] = 1;    &#125;    // 从第0个点（编号为1）开始深搜    dfs(0);    printf(&quot;%d&quot;, ans);    return 0;&#125;\n\n核心部分在于 loop 输入和 dfs 的递归调用\n关于 loop 可以设置 loop 标签，在循环末尾计数器自增后判断如果符合循环条件则跳转到 loop ，否则顺延即结束循环\n还有一种写法再设置一个 continue 标签，可将跳转到 continue 作为 break\n关于 dfs 的实现这里笔者选择多传入一个计数器 sum ，这样可以少写一个循环来判断是否走完全程\n由于 G 和 book 都只看 01 ，这里笔者耍了小聪明选择 sb 和 lb 但是参数数量对不上导致 word 存储出错，我真是个大 sb\n解决方法也比较粗暴，单开一个 t7 作为  sum .\nPre上机\n我是猪\n\n心路历程Logisim 是个走地图，如果下一目标点违法（超出图外或是位于障碍处），那么就输出flag &#x3D; 1 一个周期（初始默认为0），并且本次不移动，如果合法就移动，如果到目标点就输出 out &#x3D; 0 ，然后采用的是异步复位信号\n猪波上来就确定 state 存 x 和 y 做 mealy 机，然后加两个判断机\n但是wa\n好在浏览了一遍后面两个很简单，skip skip skip\nVerilog 是输入 32 位，然后 4 位一划分对每个数据变换，然后再拼回去输出，是简单的组合逻辑，至于 %16 的要求，让他自然溢出即可\n这里给自己下了个小绊子，a0 忘记 assign 乐，好在看波形可以很轻松看出来\nMars 输入一个矩阵，根据输入参数输出其中的小矩阵，其实两次循环基本上结构差不多，写个 getaddress 的宏会很方便，记得 *4 对齐 word\n然后这里猪波又发癫了，输入 16 个数据发现还要输入，以为输入写错了，结果后面本来就要再输入 4 个参数\n最后 Logisim 很自然地找到了是 flag 输出地问题，九点之前疯狂改输出逻辑，但是无果，然后过时间了发现 pre 免费加长 60 分钟，然后冷静下来，盯着题目看见提示 reset后为0 想起来没给 flag 输出的寄存器接 reset\n总而言之，我是猪\n","categories":["CO"],"tags":["MIPS","Logisim","Verilog"]}]